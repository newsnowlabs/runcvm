#!/bin/sh
# RunCVM VM Init for Firecracker
# 
# This script runs inside the Firecracker VM where the rootfs is from the container image.
# We use /bin/sh (busybox from Alpine) instead of bundled bash.

set -e

RUNCVM_GUEST="${RUNCVM_GUEST:-/.runcvm/guest}"
SSHD_PORT="${SSHD_PORT:-22222}"

log() {
  echo "RunCVM-FC-Init: $1"
}

mount_9p_volumes() {
  local mount_config="/.runcvm/9p-mounts"
  
  [ -f "$mount_config" ] || return 0
  
  # Connect to container's bridge IP for diod server
  # The bridge IP 169.254.1.1 is set in runcvm-ctr-entrypoint
  # This is reachable from the VM since it's on the same bridge network
  local host_ip="169.254.1.1"
  
  log "Mounting 9P volumes via TCP (host: $host_ip)..."
  
  while IFS=: read -r port dst; do
    [ -z "$port" ] && continue
    
    log "  Mounting $dst from $host_ip:$port"
    
    mkdir -p "$dst"
    
    # Use TCP transport to connect to diod server on host
    mount -t 9p \
      -o trans=tcp,dfltuid=0,dfltgid=0,version=9p2000.L,port=$port,msize=65536,cache=loose \
      "$host_ip" "$dst"
    
    if [ $? -eq 0 ]; then
      log "  ✓ Mounted $dst successfully"
    else
      log "  ✗ Failed to mount $dst"
    fi
  done < "$mount_config"
}

log "Starting Firecracker VM initialization..."

# ============================================================
# MOUNT ESSENTIAL FILESYSTEMS
# ============================================================

# Root should already be mounted by kernel, remount rw if needed
mount -o remount,rw / 2>/dev/null || true

# Mount proc if not mounted
if ! mountpoint -q /proc 2>/dev/null; then
  mkdir -p /proc
  mount -t proc proc /proc
fi

# Mount sysfs if not mounted
if ! mountpoint -q /sys 2>/dev/null; then
  mkdir -p /sys
  mount -t sysfs sysfs /sys
fi

# Mount devtmpfs if not mounted  
if ! mountpoint -q /dev 2>/dev/null; then
  mkdir -p /dev
  mount -t devtmpfs devtmpfs /dev
fi

# Create pts and shm
mkdir -p /dev/pts /dev/shm
mount -t devpts devpts /dev/pts 2>/dev/null || true
mount -t tmpfs tmpfs /dev/shm 2>/dev/null || true

# Mount devtmpfs if not already mounted
if ! mountpoint -q /dev; then
    mount -t devtmpfs devtmpfs /dev
fi

# Create /dev/fd symlinks
[ -e /dev/fd ] || ln -sf /proc/self/fd /dev/fd
[ -e /dev/stdin ] || ln -sf /proc/self/fd/0 /dev/stdin
[ -e /dev/stdout ] || ln -sf /proc/self/fd/1 /dev/stdout
[ -e /dev/stderr ] || ln -sf /proc/self/fd/2 /dev/stderr

log "Filesystems mounted"

# ============================================================
# LOAD CONFIGURATION
# The config file may contain bash 'declare -x' syntax
# We need to convert it to sh-compatible format
# ============================================================

if [ -f /.runcvm/config ]; then
  # Convert 'declare -x VAR="value"' to 'export VAR="value"'
  # and source it
  sed 's/^declare -x /export /' /.runcvm/config > /tmp/config.sh 2>/dev/null || true
  . /tmp/config.sh 2>/dev/null || true
  rm -f /tmp/config.sh
fi

# ============================================================
# NETWORK CONFIGURATION
# ============================================================

log "Configuring network..."

# Bring up loopback
ip link set lo up 2>/dev/null || true

# Configure eth0 if network config exists
if [ -f "/.runcvm/network/devices/eth0" ]; then
  read DOCKER_IF DOCKER_IF_MAC DOCKER_IF_MTU DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_IP_GW < /.runcvm/network/devices/eth0
  
  if [ -n "$DOCKER_IF_IP" ] && [ -n "$DOCKER_IF_IP_NETPREFIX" ]; then
    ip addr add "$DOCKER_IF_IP/$DOCKER_IF_IP_NETPREFIX" broadcast + dev eth0 2>/dev/null || true
    ip link set eth0 up mtu "${DOCKER_IF_MTU:-1500}" 2>/dev/null || true
    
    if [ -n "$DOCKER_IF_IP_GW" ] && [ "$DOCKER_IF_IP_GW" != "-" ]; then
      ip route add default via "$DOCKER_IF_IP_GW" dev eth0 2>/dev/null || true
    fi
    
    log "Network configured: $DOCKER_IF_IP/$DOCKER_IF_IP_NETPREFIX gw $DOCKER_IF_IP_GW"
  fi
else
  # Try to bring up eth0 anyway
  ip link set eth0 up 2>/dev/null || true
  log "Network: eth0 up (no config file)"
fi

# Install supplementary routes
if [ -f "/.runcvm/network/routes" ]; then
  while read rt_net rt_gw rt_dev rt_prefsrc; do
    [ -n "$rt_net" ] && [ -n "$rt_gw" ] && [ -n "$rt_dev" ] && \
      ip route add "$rt_net" via "$rt_gw" dev "$rt_dev" 2>/dev/null || true
  done < /.runcvm/network/routes
fi

# ============================================================
# HOSTNAME
# ============================================================

if [ -f /etc/hostname ]; then
  hostname -F /etc/hostname
  log "Hostname: $(hostname)"
fi

# ============================================================
# WORKING DIRECTORY
# ============================================================

if [ -f /.runcvm/pwd ]; then
  cd "$(cat /.runcvm/pwd)" 2>/dev/null || cd /
fi

# ============================================================
# KERNEL AND 9P DEBUG INFORMATION
# ============================================================

log "========== KERNEL DEBUG INFO =========="

# Show kernel version and build date
log "Kernel version: $(uname -r)"
log "Kernel build: $(uname -v)"

# Check if 9P is built into the kernel or available as modules
log "9P Filesystem Support:"
if grep -q "^nodev.*9p$" /proc/filesystems 2>/dev/null; then
  log "  ✓ 9P filesystem: BUILT-IN (in /proc/filesystems)"
else
  log "  ✗ 9P filesystem: NOT in /proc/filesystems (may need module load)"
fi

# Check for 9P transports
if [ -f /proc/net/9p/transports ]; then
  log "  ✓ /proc/net/9p/transports exists"
  log "  Available transports: $(cat /proc/net/9p/transports 2>/dev/null || echo 'ERROR reading file')"
else
  log "  ✗ /proc/net/9p/transports NOT FOUND (9P networking not initialized)"
fi

# Check if vsock is available
if [ -c /dev/vsock ]; then
  log "  ✓ /dev/vsock device exists"
else
  log "  ✗ /dev/vsock device NOT FOUND"
fi

# Check loaded modules related to 9P
log "Loaded 9P/vsock modules:"
if [ -f /proc/modules ]; then
  grep -E "9p|vsock" /proc/modules 2>/dev/null | while read mod rest; do
    log "  - $mod"
  done || log "  (no 9P/vsock modules loaded)"
else
  log "  /proc/modules not available"
fi

log "======================================="

# ============================================================
# LAUNCH ENTRYPOINT
# ============================================================

# Load 9P modules directly with insmod (bypass version check)
# We use TCP transport, so we need 9pnet_fd (not 9pnet_vsock)
log "Loading 9P kernel modules..."
MOD_DIR="/lib/modules"
if [ -d "$MOD_DIR" ]; then
  # Find the module directory
  KVER=$(ls "$MOD_DIR" | head -1)
  if [ -n "$KVER" ] && [ -d "$MOD_DIR/$KVER/kernel/net" ]; then
    log "  Found modules for $KVER"
    
    # Load in dependency order for TCP transport
    insmod "$MOD_DIR/$KVER/kernel/net/9p/9pnet.ko" 2>/dev/null && log "  ✓ Loaded 9pnet" || log "  (9pnet built-in or unavailable)"
    insmod "$MOD_DIR/$KVER/kernel/net/9p/9pnet_fd.ko" 2>/dev/null && log "  ✓ Loaded 9pnet_fd" || log "  (9pnet_fd built-in or unavailable)"
    insmod "$MOD_DIR/$KVER/kernel/fs/9p/9p.ko" 2>/dev/null && log "  ✓ Loaded 9p" || log "  (9p built-in or unavailable)"
  else
    log "  WARNING: Module directory not found in $MOD_DIR"
  fi
else
  log "  (No external modules needed - 9P FD transport built into kernel)"
fi

log "mount 9p volumes"
mount_9p_volumes

log "Preparing to launch entrypoint..."

# Read and execute entrypoint
if [ -f /.runcvm/entrypoint ]; then
  # Build command from entrypoint file (one arg per line)
  CMD=""
  while IFS= read -r line || [ -n "$line" ]; do
    if [ -z "$CMD" ]; then
      CMD="$line"
    else  
      # Quote arguments that contain spaces
      case "$line" in
        *\ *) CMD="$CMD \"$line\"" ;;
        *) CMD="$CMD $line" ;;
      esac
    fi
  done < /.runcvm/entrypoint
  
  log "Executing: $CMD"
  
  # Run the command (not exec - we need to capture exit and shutdown)
  eval $CMD
  EXIT_CODE=$?
  
  log "Command exited with code: $EXIT_CODE"
  
  # Save exit code for potential retrieval
  echo "$EXIT_CODE" > /.runcvm/exitcode 2>/dev/null || true
  
  # Trigger clean shutdown
  # Firecracker catches the reboot syscall and exits cleanly
  log "Shutting down VM..."
  
  # Sync filesystems first
  sync
  
  # Try multiple methods to trigger reboot/shutdown
  # Method 1: Use /proc/sysrq-trigger (most reliable)
  if [ -w /proc/sysrq-trigger ]; then
    echo s > /proc/sysrq-trigger 2>/dev/null  # sync
    echo o > /proc/sysrq-trigger 2>/dev/null  # poweroff
  fi
  
  # Method 2: reboot syscall via busybox or coreutils
  reboot -f 2>/dev/null || /sbin/reboot -f 2>/dev/null || true
  
  # Method 3: Direct poweroff
  poweroff -f 2>/dev/null || /sbin/poweroff -f 2>/dev/null || true
  
  # If we get here, sleep briefly and let kernel handle it
  # The kernel panic on init exit is actually fine - Firecracker sees it as clean exit
  sleep 1
  exit $EXIT_CODE
else
  log "No entrypoint found, starting shell"
  exec /bin/sh -l
fi
