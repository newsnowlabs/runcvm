#!/opt/runcvm/bin/bash

# TODO: Clean up ENV vars
. /.runcvm/config

# Load defaults after exports (so that PATH is overridden)
. /opt/runcvm/scripts/runcvm-ctr-defaults && PATH="$RUNCVM_PATH"

# Load network config
load_network

# BREAK="break=mountroot"
PANIC="panic=-1"

INIT="init=/opt/runcvm/scripts/runcvm-vm-init"

SERIAL="mon:stdio"
# SERIAL="stdio"

MAC=$(busybox sed -r 's/^..:..:../52:54:00/' <<<$DOCKER_IF_MAC)

error() {
  echo "$1" >&2
  exit 1
}

# Argument e.g. /volume/disk1,/var/lib/docker,ext4,5G
do_disk() {
  local spec="$1"
  local src dst fs size

  local IFS=','
  read src dst fs size <<< $(echo "$spec")

  if [[ -z "$src" || -z "$dst" || -z "$fs" ]]; then
    error "Error: disk spec '$spec' invalid: src, dst and fs must all be specified"
  fi

  if [[ "$src" = "$dst" ]]; then
    error "Error: disk spec '$spec' invalid: src '$src' cannot be same as dst"
  fi

  if [[ -e "$src" && ! -f "$src" ]]; then
    error "Error: disk spec '$spec' invalid: src '$src' must be a plain file if it exists"
  fi

  if [[ -e "$dst" && ! -d "$dst" ]]; then
    error "Error: disk spec '$spec' invalid: dst '$dst' must be a directory if it exists"
  fi

  if [[ ! -f "$src" ]]; then
    
    if [[ -z "$size" ]]; then
      error "Error: disk spec '$spec' invalid: size must be specified if src '$src' does not exist"
    fi

    busybox truncate -s "$size" "$src" >&2 || error "Error: disk spec '$spec' invalid: truncate on '$src' with size '$size' failed"
    mke2fs -F -t "$fs" "$src" >&2 || error "Error: disk spec '$spec' invalid: mke2fs on '$src' with fs '$fs' failed"
  fi

  UUID=$(blkid -o value "$src" | head -n 1)
  mkdir -p "$RUNCVM_VM_MOUNTPOINT/$dst" >&2
  echo "UUID=$UUID $dst $fs defaults,noatime 0 0" >>/.runcvm/fstab
  DISKS+=("-drive file=$src,format=raw,if=virtio,media=disk,cache=directsync,aio=native")
}

# Argument e.g. /disk1,/home,ext4,5G;/disk2,/var,ext4,1G
do_disks() {
  local IFS=';'
  for disk in $1
  do
    do_disk "$disk"
  done
}

DISKS=()
if [ -n "$RUNCVM_DISKS" ]; then
  do_disks "$RUNCVM_DISKS"
fi

if [ -n "$RUNCVM_TMPFS" ]; then
  echo "$RUNCVM_TMPFS" >>/.runcvm/fstab
fi

if [[ -z "$RUNCVM_CPUS" || "$RUNCVM_CPUS" -le 0 ]]; then
  RUNCVM_CPUS=$(busybox nproc)
fi

# TODO:
# - Consider using '-device pvpanic'

if [ "$RUNCVM_ARCH" = "arm64" ]; then
  CMD="qemu-system-aarch64"
  OPTS=(-cpu max -machine virt,gic-version=max,usb=off)
else
  CMD="qemu-system-x86_64"
  OPTS=(-enable-kvm -cpu host -machine q35,accel=kvm,usb=off,sata=off -device isa-debug-exit)
fi

if [ -n "$RUNCVM_QEMU_DISPLAY" ]; then
  OPTS+=(-display $RUNCVM_QEMU_DISPLAY)
else
  OPTS+=(-nographic)
fi

if [ "$RUNCVM_KERNEL_DEBUG" = "1" ]; then
  APPEND=("console=ttyS0")
fi

if [ "$RUNCVM_BIOS_DEBUG" != "1" ]; then
  # Disable SeaBIOS serial console.
  # This -cfw_cfg path is modified from the SeaBIOS default (to avoid an otherwise-inevitable QEMU
  # warning being emitted) and so requires patched bios.bin file(s) (see Dockerfile)
  OPTS+=(-fw_cfg opt/org.seabios/etc/sercon-port,string=0)
fi

ARGS=(
  "${OPTS[@]}"
  -no-user-config
  -nodefaults
  -serial $SERIAL
  -m "$RUNCVM_MEM_SIZE"
  -chardev socket,id=char0,path=$QEMU_VIRTIOFSD_SOCKET
  -device vhost-user-fs-pci,queue-size=1024,chardev=char0,tag=myfs,ats=on
  -kernel $RUNCVM_KERNEL_PATH
  -initrd $RUNCVM_KERNEL_INITRAMFS_PATH
  -append "$RUNCVM_KERNEL_ROOT $INIT rw ${APPEND[@]} $PANIC $RUNCVM_KERNEL_APPEND $BREAK"
  -object memory-backend-file,id=mem,size="$RUNCVM_MEM_SIZE",mem-path=/dev/shm,share=on
  -numa node,memdev=mem
  -smp $RUNCVM_CPUS
  # Configure host/container tap device with PXE roms disabled
  -netdev tap,id=qemu0,script=$QEMU_IFUP,downscript=$QEMU_IFDOWN -device virtio-net-pci,netdev=qemu0,mac=$MAC,rombar=0
  -no-reboot
  ${DISKS[@]}
  -action panic=none -action reboot=shutdown
  -monitor unix:$QEMU_MONITOR_SOCKET,server,nowait
  -chardev socket,id=charchannel0,path=$QEMU_GUEST_AGENT,server=on,wait=off
  -device virtio-serial
  -device virtserialport,chardev=charchannel0,name=org.qemu.guest_agent.0
)

if [[ "$RUNCVM_BREAK" =~ preqemu ]]; then echo Preparing to run: $CMD "${ARGS[@]@Q}"; bash; fi

exec $CMD "${ARGS[@]}"
