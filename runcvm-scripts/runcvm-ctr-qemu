#!/opt/runcvm/bin/bash

# TODO: Clean up ENV vars
. /.runcvm/config

# Load defaults after exports (so that PATH is overridden)
. /opt/runcvm/scripts/runcvm-ctr-defaults && PATH="$RUNCVM_PATH"

QEMU_IFUP="$RUNCVM/scripts/runcvm-ctr-qemu-ifup"
QEMU_IFDOWN="$RUNCVM/scripts/runcvm-ctr-qemu-ifdown"

# BREAK="break=mountroot"
PANIC="panic=-1"

INIT="init=/opt/runcvm/scripts/runcvm-vm-init"

SERIAL="mon:stdio"
# SERIAL="stdio"

MACHINE="pc" # || "microvm"

error() {
  echo "$1" >&2
  exit 1
}

# Argument e.g. /volume/disk1,/var/lib/docker,ext4,5G
do_disk() {
  local spec="$1"
  local src dst fs size

  local IFS=','
  read src dst fs size <<< $(echo "$spec")

  if [[ -z "$src" || -z "$dst" || -z "$fs" ]]; then
    error "Error: disk spec '$spec' invalid: src, dst and fs must all be specified"
  fi

  if [[ "$src" = "$dst" ]]; then
    error "Error: disk spec '$spec' invalid: src '$src' cannot be same as dst"
  fi

  if [[ -e "$src" && ! -f "$src" ]]; then
    error "Error: disk spec '$spec' invalid: src '$src' must be a plain file if it exists"
  fi

  if [[ -e "$dst" && ! -d "$dst" ]]; then
    error "Error: disk spec '$spec' invalid: dst '$dst' must be a directory if it exists"
  fi

  if [[ ! -f "$src" ]]; then
    
    if [[ -z "$size" ]]; then
      error "Error: disk spec '$spec' invalid: size must be specified if src '$src' does not exist"
    fi

    busybox truncate -s "$size" "$src" >&2 || error "Error: disk spec '$spec' invalid: truncate on '$src' with size '$size' failed"
    mke2fs -F -t "$fs" "$src" >&2 || error "Error: disk spec '$spec' invalid: mke2fs on '$src' with fs '$fs' failed"
  fi

  local UUID=$(blkid -o value "$src" | head -n 1)
  mkdir -p "$RUNCVM_VM_MOUNTPOINT/$dst" >&2
  echo "UUID=$UUID $dst $fs defaults,noatime 0 0" >>/.runcvm/fstab
  DISKS+=("-drive file=$src,format=raw,if=virtio,media=disk,cache=directsync,aio=native")
}

# Argument e.g. /disk1,/home,ext4,5G;/disk2,/var,ext4,1G
do_disks() {
  local IFS=';'
  local disk
  for disk in $1
  do
    do_disk "$disk"
  done
}

do_networks() {
  local id=0 ifpath if mac
  local viodev opts
  local DOCKER_IF DOCKER_IF_MAC DOCKER_IF_MTU DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_IP_GW

  for ifpath in /.runcvm/network/devices/*
  do
    if=$(busybox basename "$ifpath")

    [ "$if" = "default" ] && continue

    load_network "$if"

    mac=$(busybox sed -r 's/^..:..:../52:54:00/' <<<$DOCKER_IF_MAC)

    if [ "$MACHINE" = "pc" ]; then
      viodev="virtio-net-pci"
      opts=",rombar=$id"
    else
      viodev="virtio-net-device"
      opts=""
    fi

    IFACES+=(
        -netdev tap,id=qemu$id,ifname=tap-$DOCKER_IF,script=$QEMU_IFUP,downscript=$QEMU_IFDOWN
        -device $viodev,netdev=qemu$id,mac=$mac$opts
    )

    id=$((id+1))
  done
}

DISKS=()
if [ -n "$RUNCVM_DISKS" ]; then
  do_disks "$RUNCVM_DISKS"
fi

IFACES=()
do_networks

if [ -n "$RUNCVM_TMPFS" ]; then
  echo "$RUNCVM_TMPFS" >>/.runcvm/fstab
fi

if [[ -z "$RUNCVM_CPUS" || "$RUNCVM_CPUS" -le 0 ]]; then
  RUNCVM_CPUS=$(busybox nproc)
fi

# TODO:
# - Consider using '-device pvpanic'

# 16-64 works well and is more performant than 1024 in some scenarios.
# For now, stick with original figure.
VIRTIOFS_QUEUE_SIZE=1024

if [ "$RUNCVM_ARCH" = "arm64" ]; then
  CMD="qemu-system-aarch64"
  OPTS=(-cpu max -machine virt,gic-version=max,usb=off)
else
  CMD="qemu-system-x86_64"
  OPTS=(-enable-kvm -cpu host -device isa-debug-exit)

  if [ "$MACHINE" = "pc" ]; then
    OPTS+=(-machine q35,accel=kvm,usb=off,sata=off)
    DEV_VHOSTFS="-device vhost-user-fs-pci,queue-size=$VIRTIOFS_QUEUE_SIZE,chardev=char0,tag=myfs,ats=on"
    DEV_SERIAL="-device virtio-serial-pci"
  else
    OPTS+=(-machine microvm,accel=kvm,usb=off)
    DEV_VHOSTFS="-device vhost-user-fs-device,queue-size=$VIRTIOFS_QUEUE_SIZE,chardev=char0,tag=myfs"
    DEV_SERIAL="-device virtio-serial-device"
  fi
fi

if [ -n "$RUNCVM_QEMU_DISPLAY" ]; then
  OPTS+=(-display $RUNCVM_QEMU_DISPLAY)
else
  OPTS+=(-nographic)
fi

if [ "$RUNCVM_KERNEL_DEBUG" = "1" ]; then
  APPEND=("console=ttyS0")
fi

if [ "$RUNCVM_BIOS_DEBUG" != "1" ]; then
  # Disable SeaBIOS serial console.
  # This -cfw_cfg path is modified from the SeaBIOS default (to avoid an otherwise-inevitable QEMU
  # warning being emitted) and so requires patched bios.bin file(s) (see Dockerfile)
  OPTS+=(-fw_cfg opt/org.seabios/etc/sercon-port,string=0)
  [ "$MACHINE" = "microvm" ] && OPTS+=(-bios bios.bin)
fi

# Disable IPv6, which is currently unsupported, at kernel boot time
APPEND+=(ipv6.disable=1)

if [ "$RUNCVM_HUGETLB" != "1" ]; then
  # Tests suggests prealloc=on slows down mem-path=/dev/shm
  MEM_PATH=/dev/shm MEM_PREALLOC=off
  MEM_BACKEND="-object memory-backend-file,id=mem,size=$RUNCVM_MEM_SIZE,mem-path=$MEM_PATH,share=on,prealloc=$MEM_PREALLOC"
else
  # Fastest performance: +15% CPU/net intensive; 3.5x disk intensive.
  MEM_BACKEND="-object memory-backend-memfd,id=mem,size=$RUNCVM_MEM_SIZE,share=on,prealloc=on,hugetlb=on"
fi

ARGS=(
  "${OPTS[@]}"
  -no-user-config
  -nodefaults
  -serial $SERIAL
  -m "$RUNCVM_MEM_SIZE"
  -chardev socket,id=char0,path=$QEMU_VIRTIOFSD_SOCKET
  $DEV_VHOSTFS
  -kernel $RUNCVM_KERNEL_PATH
  -initrd $RUNCVM_KERNEL_INITRAMFS_PATH
  -append "$RUNCVM_KERNEL_ROOT $INIT rw ${APPEND[*]} $PANIC $RUNCVM_KERNEL_APPEND $BREAK"
  $MEM_BACKEND
  -numa node,memdev=mem
  -smp $RUNCVM_CPUS
  # Configure host/container tap device with PXE roms disabled
  ${IFACES[@]}
  -no-reboot
  ${DISKS[@]}
  -action panic=none -action reboot=shutdown
  -monitor unix:$QEMU_MONITOR_SOCKET,server,nowait
  -chardev socket,id=charchannel0,path=$QEMU_GUEST_AGENT,server=on,wait=off
  $DEV_SERIAL
  -device virtserialport,chardev=charchannel0,name=org.qemu.guest_agent.0

  # Set monitor escape key to CTRL-T to reduce risk of conflict (as default, CTRL-A, is  commonly used)
  -echr 20
)

if [[ "$RUNCVM_BREAK" =~ preqemu ]]; then echo Preparing to run: $CMD "${ARGS[@]@Q}"; bash; fi

exec $CMD "${ARGS[@]}"
