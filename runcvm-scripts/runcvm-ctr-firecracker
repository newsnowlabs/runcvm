#!/.runcvm/guest/bin/bash

# RunCVM Firecracker Launcher
# Launches a Firecracker microVM using config file mode (for console output)

set -o errexit -o pipefail

# Load original environment
. /.runcvm/config

# Load defaults
. $RUNCVM_GUEST/scripts/runcvm-ctr-defaults && unset PATH

FIRECRACKER_BIN="$RUNCVM_GUEST/sbin/firecracker"
FIRECRACKER_CONFIG="/run/.firecracker-config.json"

log() {
  echo "RunCVM-FC: $1" >&2
}

error() {
  echo "RunCVM-FC ERROR: $1" >&2
  exit 1
}

# Create rootfs image from container filesystem
create_rootfs() {
  local source_dir="$1"
  local image_path="$2"
  local size_mb="$3"
  
  log "Creating rootfs: $image_path (${size_mb}MB) from $source_dir"
  
  # Create sparse file
  busybox truncate -s "${size_mb}M" "$image_path"
  
  # Create ext4 filesystem populated with source directory contents
  mke2fs -q -F -t ext4 -d "$source_dir" "$image_path" >/dev/null 2>&1
  
  log "Rootfs created"
}

# Main function
main() {
  log "Starting Firecracker microVM launcher..."
  
  # Check for Firecracker binary
  if [ ! -x "$FIRECRACKER_BIN" ]; then
    error "Firecracker binary not found: $FIRECRACKER_BIN"
  fi
  
  # Calculate rootfs size (source size + 256MB headroom, minimum 512MB)
  local rootfs_size=$(( $(busybox du -sm "$RUNCVM_VM_MOUNTPOINT" | busybox cut -f1) + 256 ))
  [ "$rootfs_size" -lt 512 ] && rootfs_size=512
  
  # Create rootfs in /dev/shm (tmpfs, sized to VM memory)
  local rootfs_path="/dev/shm/rootfs.ext4"
  create_rootfs "$RUNCVM_VM_MOUNTPOINT" "$rootfs_path" "$rootfs_size"
  
  # Determine kernel path - USE FIRECRACKER KERNEL BY DEFAULT
  local fc_default_kernel="$RUNCVM_GUEST/firecracker-kernel"
  local kernel_path="${RUNCVM_FC_KERNEL_PATH:-$fc_default_kernel}"
  
  log "Kernel: $kernel_path"
  
  if [ ! -f "$kernel_path" ]; then
    error "Firecracker kernel not found: $kernel_path"
  fi
  
  # Build boot arguments
  local boot_args="init=$RUNCVM_GUEST/scripts/runcvm-vm-init-firecracker console=ttyS0 reboot=k panic=1 pci=off root=/dev/vda rw"
  
  # Parse memory size (remove 'M' suffix if present)
  local mem_mb="${RUNCVM_MEM_SIZE%M}"
  [ -z "$mem_mb" ] && mem_mb=768
  
  # Parse CPU count
  local vcpu_count="${RUNCVM_CPUS:-1}"
  [ "$vcpu_count" -le 0 ] && vcpu_count=$(busybox nproc)
  
  log "VM config: $vcpu_count vCPUs, $mem_mb MiB RAM"
  
  # Build network config if available
  local network_config=""
  if [ -f "/.runcvm/network/devices/eth0" ]; then
    read DOCKER_IF DOCKER_IF_MAC DOCKER_IF_MTU DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_IP_GW < /.runcvm/network/devices/eth0
    local fc_mac=$(echo "$DOCKER_IF_MAC" | busybox sed 's/^..:..:../AA:FC:00/')
    log "Network: tap-$DOCKER_IF ($fc_mac)"
    network_config=",\"network-interfaces\":[{\"iface_id\":\"eth0\",\"guest_mac\":\"$fc_mac\",\"host_dev_name\":\"tap-$DOCKER_IF\"}]"
  fi
  
  # Create Firecracker config file
  # Note: Using config file mode allows console to be connected to stdio
  cat > "$FIRECRACKER_CONFIG" << CFGEOF
{
  "boot-source": {
    "kernel_image_path": "$kernel_path",
    "boot_args": "$boot_args"
  },
  "drives": [
    {
      "drive_id": "rootfs",
      "path_on_host": "$rootfs_path",
      "is_root_device": true,
      "is_read_only": false
    }
  ],
  "machine-config": {
    "vcpu_count": $vcpu_count,
    "mem_size_mib": $mem_mb
  }${network_config}
}
CFGEOF

  log "Config file created: $FIRECRACKER_CONFIG"
  
  # Show config for debugging
  log "Config contents:"
  cat "$FIRECRACKER_CONFIG" >&2
  
  log "Starting Firecracker VM..."
  
  # Run Firecracker with config file (this connects console to stdio)
  # --no-api disables the API server, which is fine since we're using config file
  "$FIRECRACKER_BIN" --no-api --config-file "$FIRECRACKER_CONFIG"
  
  local exit_code=$?
  log "Firecracker exited with code $exit_code"
  
  # Cleanup
  rm -f "$rootfs_path" "$FIRECRACKER_CONFIG"
  
  return $exit_code
}

main "$@"
