#!/.runcvm/guest/bin/bash

# RunCVM Firecracker Launcher
# Launches a Firecracker microVM using config file mode (for console output)
#
# STRATEGY: Copy container files to /dev/shm, then create rootfs on overlay
# This avoids the self-copy problem where mke2fs would copy the rootfs into itself

set -o errexit -o pipefail

# Load original environment
. /.runcvm/config

# Load defaults
. $RUNCVM_GUEST/scripts/runcvm-ctr-defaults && unset PATH

FIRECRACKER_BIN="$RUNCVM_GUEST/sbin/firecracker"
FIRECRACKER_CONFIG="/run/.firecracker-config.json"
FUSED_BIN="$RUNCVM_GUEST/bin/runcvm-fused"
FUSE_CLIENT_BIN="$RUNCVM_GUEST/bin/runcvm-fuse-client"
FUSE_CONFIG="/.runcvm/fuse-volumes"

# ============================================================
# LOGGING SYSTEM
# Severity levels: DEBUG, INFO, ERROR, OFF
# Control via: RUNCVM_LOG_LEVEL environment variable
# ============================================================

# Default log level (can be overridden by environment)
RUNCVM_LOG_LEVEL="${RUNCVM_LOG_LEVEL:-OFF}"

# Log severity levels (numeric for comparison)
declare -A LOG_LEVELS=(
  [DEBUG]=0
  [INFO]=1
  [LOG]=1      # Alias for INFO
  [ERROR]=2
  [OFF]=999
)

# Get numeric level for current log level (default to OFF=999)
CURRENT_LOG_LEVEL="${LOG_LEVELS[$RUNCVM_LOG_LEVEL]:-999}"

# Core logging function
_log() {
  local severity="$1"
  shift
  local message="$*"
  local severity_level="${LOG_LEVELS[$severity]:-1}"
  
  # Only log if severity meets threshold
  if [ "$severity_level" -ge "$CURRENT_LOG_LEVEL" ]; then
    echo "[$(busybox date '+%Y-%m-%d %H:%M:%S')] [RunCVM-FC] [$severity] $message" >&2
  fi
}

# Convenience functions for different severity levels
log_debug() {
  _log DEBUG "$@"
}

log_info() {
  _log INFO "$@"
}

log() {
  # Default log function - maps to INFO for backward compatibility
  _log INFO "$@"
}

log_error() {
  _log ERROR "$@"
}

error() {
  log_error "$@"
  exit 1
}

create_volumes_from_vm_mounts() {
  local volumes_file="/.runcvm/volumes"
  local vm_mountpoint="${RUNCVM_VM_MOUNTPOINT:-/vm}"
  
  log "Creating volumes file from mounted directories..."
  
  > "$volumes_file"
  
  # Look at directories under /vm that are mountpoints
  for dir in "$vm_mountpoint"/*; do
    [ -d "$dir" ] || continue
    
    # Skip system directories
    case "$dir" in
      */etc|*/proc|*/sys|*/dev|*/run|*/.runcvm) continue ;;
    esac
    
    # Check if it's a mountpoint (different device than parent)
    if busybox mountpoint -q "$dir" 2>/dev/null; then
      local container_path="${dir#$vm_mountpoint}"
      # Get the source from findmnt or /proc/mounts
      local source=$(busybox awk -v mp="$dir" '$2 == mp {print $1; exit}' /proc/mounts)
      
      # If source is a device, try to find the actual bind source
      if [ -n "$source" ]; then
        log "  Found mountpoint: $dir (source: $source)"
        echo "${dir}:${container_path}:rw" >> "$volumes_file"
      fi
    fi
  done
  
  if [ -s "$volumes_file" ]; then
    log "Volumes file created with $(busybox wc -l < "$volumes_file") entries"
    busybox cat "$volumes_file" | while read line; do log "  $line"; done
  else
    log "No volume mountpoints detected"
  fi
}

setup_fuse_volumes() {
  # Pure FUSE over vsock using runcvm-fused (Rust daemon)
  # Host: runcvm-fused daemon listens on Unix socket (Firecracker vsock bridge)
  # Guest: runcvm-fuse-client connects via vsock
  #
  # Firecracker vsock architecture:
  #   Guest (vsock CID 2, port 5742) -> Firecracker -> UDS /run/firecracker.vsock_5742 -> Host daemon
  
  local fuse_config="/.runcvm/fuse-volumes"
  local fused_bin="$RUNCVM_GUEST/bin/runcvm-fused"
  local vsock_port="5742"
  local vsock_uds="/run/firecracker.vsock"
  
  # Read volume mounts from OCI config  
  if [ -f "/.runcvm/volumes" ]; then
    > "$fuse_config"
    
    log "Setting up FUSE volumes (pure FUSE over vsock)"
    log "  Transport: vsock (Guest -> Host CID 2, port $vsock_port)"
    log "  Host UDS: ${vsock_uds}_${vsock_port}"
    log "  Latency: ~1-2ms (near-native)"
    
    # Record volumes for guest to mount
    # Format: src:dst:opts
    while IFS=: read -r src dst opts; do
      [ -z "$src" ] && continue
      
      log "  Volume: $src -> $dst"
      
      # Write config for guest (format: src:dst:opts)
      echo "$src:$dst:$opts" >> "$fuse_config"
      
    done < /.runcvm/volumes
    
    # Start the Rust FUSE daemon
    # Note: Daemon must start BEFORE Firecracker so it's ready when guest connects
    if [ -x "$fused_bin" ]; then
      log "  Starting runcvm-fused daemon..."
      "$fused_bin" \
        --vsock-port "$vsock_port" \
        --vsock-uds "$vsock_uds" \
        --volumes-config "$fuse_config" \
        >"/run/runcvm-fused.log" 2>&1 &
      FUSED_PID=$!
      log "    runcvm-fused started (PID: $FUSED_PID)"
      log "    Listening on: ${vsock_uds}_${vsock_port}"
    else
      log "WARNING: runcvm-fused not found at $fused_bin"
      log "  Falling back to static volume copy mode"
    fi
    
    log "  FUSE config written to $fuse_config"
    
  else
    log "  No volumes file found, skipping FUSE volume setup"
  fi
}

cleanup_fuse_volumes() {
  # Cleanup runcvm-fused daemon
  if [ -n "$FUSED_PID" ]; then
    kill "$FUSED_PID" 2>/dev/null || true
  fi
  busybox pkill -f "runcvm-fused" 2>/dev/null || true
}

trap cleanup_fuse_volumes EXIT SIGTERM SIGINT

# Create rootfs image from a source directory
create_rootfs_from_dir() {
  local source_dir="$1"
  local image_path="$2"
  local size_mb="$3"
  
  log "Creating ext4 rootfs: $image_path (${size_mb}MB) from $source_dir"
  
  # Create sparse file
  if ! busybox truncate -s "${size_mb}M" "$image_path"; then
    error "Failed to create sparse file"
  fi
  
  # Create ext4 filesystem populated with source directory contents
  if [ "$RUNCVM_LOG_LEVEL" = "DEBUG" ]; then
    # Show mke2fs output in debug mode
    if ! mke2fs -F -t ext4 -E root_owner=0:0 -d "$source_dir" "$image_path" 2>&1; then
      log "mke2fs failed"
      busybox rm -f "$image_path"
      return 1
    fi
  else
    # Silent mode - redirect to /dev/null
    if ! mke2fs -F -t ext4 -E root_owner=0:0 -d "$source_dir" "$image_path" >/dev/null 2>&1; then
      log_error "mke2fs failed"
      busybox rm -f "$image_path"
      return 1
    fi
  fi
  log "Rootfs created successfully"
  return 0
}

# Main function
main() {
  log "Starting Firecracker microVM launcher..."
  # ==========================================================================
  # STEP 0: Extract volumes and start 9P servers BEFORE creating rootfs
  # ==========================================================================
  
  # Create volumes file if it doesn't exist
  if [ ! -f "/.runcvm/volumes" ]; then
    create_volumes_from_vm_mounts
  fi

  setup_fuse_volumes

  log_debug "FUSE_CONFIG=$FUSE_CONFIG"
  log_debug "Contents of $FUSE_CONFIG:"
  busybox cat "$FUSE_CONFIG" 2>&1 | while read line; do log_debug "  $line"; done
  
  # Check for Firecracker binary
  if [ ! -x "$FIRECRACKER_BIN" ]; then
    error "Firecracker binary not found: $FIRECRACKER_BIN"
  fi
  
  # ==========================================================================
  # STRATEGY: Copy container files to /dev/shm, then create rootfs on overlay
  # ==========================================================================
  # Problem: /vm is a bind mount of /, so any file at /x is also at /vm/x
  #          This causes mke2fs -d /vm to copy the rootfs into itself
  #
  # Solution: 
  #   1. Copy /vm contents to /dev/shm/rootfs-staging (separate tmpfs)
  #   2. Create rootfs at /rootfs.ext4 (on overlay, has disk space)
  #   3. mke2fs reads from /dev/shm, writes to /rootfs.ext4
  #   4. No self-copy because source (/dev/shm) != destination parent (/)
  # ==========================================================================
  
  local staging_dir="/dev/shm/rootfs-staging"
  local rootfs_path="/rootfs.ext4"
  
  # Calculate source size (excluding .runcvm which has RunCVM binaries)
  log "Calculating container size (excluding .runcvm)..."
  
  local source_size=$(busybox du -sm --exclude='.runcvm' "$RUNCVM_VM_MOUNTPOINT" 2>/dev/null | busybox cut -f1)
  [ -z "$source_size" ] && source_size=100
  
  log "Container filesystem size: ${source_size}MB"
  
  # Check if /dev/shm has enough space for staging
  local shm_avail=$(busybox df -m /dev/shm 2>/dev/null | busybox awk 'NR==2 {print $4}')
  local shm_needed=$(( source_size + 50 ))  # Add 50MB buffer
  
  log "/dev/shm available: ${shm_avail}MB, need for staging: ${shm_needed}MB"
  
  if [ "$shm_avail" -lt "$shm_needed" ]; then
    log ""
    log "============================================================"
    log "ERROR: /dev/shm too small for staging"
    log "============================================================"
    log ""
    log "Container size: ${source_size}MB"
    log "/dev/shm available: ${shm_avail}MB"
    log "/dev/shm is sized by the -m (memory) flag"
    log ""
    log "SOLUTION: Increase VM memory to at least ${shm_needed}m"
    log ""
    log "  docker run --runtime=runcvm -m ${shm_needed}m \\"
    log "    -e RUNCVM_HYPERVISOR=firecracker nginx"
    log ""
    log "============================================================"
    error "Insufficient /dev/shm for staging (need ${shm_needed}MB, have ${shm_avail}MB)"
  fi
  
  # Step 1: Copy container files to staging area
  log "Step 1/3: Copying container files to staging area..."
  log "  Source: $RUNCVM_VM_MOUNTPOINT (excluding .runcvm)"
  log "  Destination: $staging_dir"
  log "  This may take 30-60 seconds for large images..."
  
  busybox rm -rf "$staging_dir"
  busybox mkdir -p "$staging_dir"
  
  # Use tar to copy, excluding .runcvm directory
  local copy_start=$(busybox date +%s)
  
  if ! (cd "$RUNCVM_VM_MOUNTPOINT" && busybox tar -cf - --exclude='.runcvm' . 2>/dev/null | busybox tar -xf - -C "$staging_dir" 2>/dev/null); then
    error "Failed to copy container files to staging"
  fi
  
  local copy_end=$(busybox date +%s)
  local copy_time=$(( copy_end - copy_start ))
  
  local staged_size=$(busybox du -sm "$staging_dir" 2>/dev/null | busybox cut -f1)
  log "  Staging complete: ${staged_size}MB copied in ${copy_time}s"
  
  # Step 1b: Create init script in staging area
  # This init script will be /init in the rootfs and runs the container's entrypoint
  log "  Creating init script..."
  
  # Read the original entrypoint from runcvm config
  local entrypoint_file="/.runcvm/entrypoint"
  local init_script="${staging_dir}/init"
  
  # Create a minimal init script
  cat > "$init_script" << 'INITEOF'
#!/bin/sh
# Firecracker minimal init for RunCVM
# This runs as PID 1 inside the Firecracker VM

# ============================================================
# LOGGING SYSTEM (sh-compatible)
# ============================================================

# Try to load RUNCVM_LOG_LEVEL from config if it exists
if [ -f /.runcvm/config ]; then
  # Extract RUNCVM_LOG_LEVEL from config (format: declare -x RUNCVM_LOG_LEVEL="VALUE")
  RUNCVM_LOG_LEVEL=$(grep '^declare -x RUNCVM_LOG_LEVEL=' /.runcvm/config 2>/dev/null | sed 's/^declare -x RUNCVM_LOG_LEVEL="\(.*\)"$/\1/' | head -1)
fi

# Default to OFF if not set
RUNCVM_LOG_LEVEL="${RUNCVM_LOG_LEVEL:-OFF}"

# Logging function (simplified for sh)
log() {
  local severity="$1"
  shift
  local message="$*"
  
  # Check log level and output accordingly
  case "$RUNCVM_LOG_LEVEL" in
    DEBUG)
      # Show all messages
      echo "[$(date '+%Y-%m-%d %H:%M:%S')] [RunCVM-FC-Init] [$severity] $message"
      ;;
    INFO|LOG)
      # Show INFO and ERROR
      case "$severity" in
        INFO|ERROR) echo "[$(date '+%Y-%m-%d %H:%M:%S')] [RunCVM-FC-Init] [$severity] $message" ;;
      esac
      ;;
    ERROR)
      # Show only ERROR
      case "$severity" in
        ERROR) echo "[$(date '+%Y-%m-%d %H:%M:%S')] [RunCVM-FC-Init] [$severity] $message" ;;
      esac
      ;;
    OFF|*)
      # Show nothing
      ;;
  esac
}

# Helper function to redirect output based on log level
# Usage: some_command $(output_redirect)
# This will redirect to /dev/null unless RUNCVM_LOG_LEVEL=DEBUG
output_redirect() {
  if [ "$RUNCVM_LOG_LEVEL" = "DEBUG" ]; then
    echo ""  # No redirection - show output
  else
    echo ">/dev/null 2>&1"  # Redirect to /dev/null
  fi
}

# Simpler helper - returns 0 if DEBUG, 1 otherwise
is_debug() {
  [ "$RUNCVM_LOG_LEVEL" = "DEBUG" ]
}

log INFO "Starting..."

# Mount essential filesystems
mount -t proc proc /proc 2>/dev/null || true
mount -t sysfs sys /sys 2>/dev/null || true
mount -t devtmpfs dev /dev 2>/dev/null || true

# Create essential device nodes if devtmpfs failed
if [ ! -c /dev/null ]; then
  mknod -m 666 /dev/null c 1 3
  mknod -m 666 /dev/zero c 1 5
  mknod -m 666 /dev/random c 1 8
  mknod -m 666 /dev/urandom c 1 9
  mknod -m 666 /dev/tty c 5 0
  mknod -m 620 /dev/console c 5 1
  mknod -m 666 /dev/ptmx c 5 2
fi

# Mount pts for proper terminal support
mkdir -p /dev/pts /dev/shm
mount -t devpts devpts /dev/pts 2>/dev/null || true
mount -t tmpfs tmpfs /dev/shm 2>/dev/null || true

# Create tmpfs for /run and /tmp
mkdir -p /run /tmp
mount -t tmpfs tmpfs /run 2>/dev/null || true
mount -t tmpfs tmpfs /tmp 2>/dev/null || true

# Create symlinks
ln -sf /proc/self/fd /dev/fd 2>/dev/null || true
ln -sf /proc/self/fd/0 /dev/stdin 2>/dev/null || true
ln -sf /proc/self/fd/1 /dev/stdout 2>/dev/null || true
ln -sf /proc/self/fd/2 /dev/stderr 2>/dev/null || true

# Setup hostname
[ -f /etc/hostname ] && hostname -F /etc/hostname 2>/dev/null || true

# Setup networking
log INFO "========== NETWORK SETUP START =========="

# Setup RunCVM tools if available
# These tools use BundELF and need the dynamic linker from the same directory
# IMPORTANT: Path must match the original /.runcvm/guest/ because of relative RPATH
RUNCVM_GUEST="/.runcvm/guest"
if [ -d "$RUNCVM_GUEST/lib" ]; then
  # The dynamic linker is at /.runcvm/guest/lib/ld
  RUNCVM_LD="$RUNCVM_GUEST/lib/ld"
  if [ -x "$RUNCVM_LD" ]; then
    log INFO "Found RunCVM tools at $RUNCVM_GUEST"
    log INFO "Checking tools structure:"
    log DEBUG "lib/ld: $(ls -la $RUNCVM_GUEST/lib/ld 2>&1)"
    log DEBUG "bin contents: $(ls -la $RUNCVM_GUEST/bin/ 2>&1 | head -10)"
    log DEBUG "bin/ip: $(ls -la $RUNCVM_GUEST/bin/ip 2>&1)"
    log DEBUG "bin/busybox: $(ls -la $RUNCVM_GUEST/bin/busybox 2>&1)"
    
    # Test the dynamic linker directly
    log INFO "Testing dynamic linker..."
    log DEBUG "Test 1 - ld exists: $(test -x $RUNCVM_LD && echo yes || echo no)"
    log DEBUG "Test 2 - busybox via ld: $($RUNCVM_LD $RUNCVM_GUEST/bin/busybox echo 'works' 2>&1)"
    
    # ip is likely a symlink to busybox, so we need to call busybox ip
    # Create wrapper functions that use the dynamic linker with busybox
    runcvm_ip() { "$RUNCVM_LD" "$RUNCVM_GUEST/bin/busybox" ip "$@"; }
    runcvm_busybox() { "$RUNCVM_LD" "$RUNCVM_GUEST/bin/busybox" "$@"; }
    HAVE_RUNCVM_TOOLS=1
  else
    log INFO "Dynamic linker not found at $RUNCVM_LD"
  fi
else
  log INFO "RunCVM tools not found at $RUNCVM_GUEST"
fi

# Bring up loopback
if [ "$HAVE_RUNCVM_TOOLS" = "1" ]; then
  runcvm_ip link set lo up 2>/dev/null || true
else
  ip link set lo up 2>/dev/null || ifconfig lo up 2>/dev/null || true
fi

# First, check what kernel modules are loaded for networking
log INFO "Checking for virtio_net module..."
if is_debug && [ -f /proc/modules ]; then
  grep -i virtio /proc/modules 2>/dev/null || echo "  No virtio modules loaded"
fi

# Check /sys/class/net to see what the kernel sees
log INFO "Kernel network interfaces in /sys/class/net:"
if is_debug; then
  ls -la /sys/class/net/ 2>/dev/null || echo "  Cannot list /sys/class/net"
fi

# Check dmesg for network-related messages
log INFO "Recent dmesg network messages:"
if is_debug; then
  dmesg 2>/dev/null | grep -iE "(eth|net|virtio)" | tail -10 || echo "  Cannot read dmesg"
fi

# Configure eth0 with static IP from saved network config
if [ -f /.runcvm-network ]; then
  log INFO "Loading network config from /.runcvm-network"
  if is_debug; then
    cat /.runcvm-network
  fi
  . /.runcvm-network
  
  # Check if eth0 exists at all
  if [ -d /sys/class/net/eth0 ]; then
    log INFO "eth0 exists in /sys/class/net"
    log DEBUG "Address: $(cat /sys/class/net/eth0/address 2>/dev/null || echo 'unknown')"
    log DEBUG "Operstate: $(cat /sys/class/net/eth0/operstate 2>/dev/null || echo 'unknown')"
    log DEBUG "Carrier: $(cat /sys/class/net/eth0/carrier 2>/dev/null || echo 'unknown')"
  else
    log ERROR "eth0 does NOT exist!"
    log INFO "Available interfaces:"
    for iface in /sys/class/net/*; do
      name=$(basename "$iface")
      log DEBUG "$name: $(cat $iface/address 2>/dev/null || echo 'no-mac')"
    done
  fi
  
  if [ -n "$FC_IP" ] && [ -n "$FC_PREFIX" ] && [ -d /sys/class/net/eth0 ]; then
    log INFO "Configuring eth0 with $FC_IP/$FC_PREFIX (MTU: ${FC_MTU:-1500})"
    
    # Determine which ip command to use
    if [ "$HAVE_RUNCVM_TOOLS" = "1" ]; then
      log INFO "Using RunCVM tools (via dynamic linker)"
      IP_CMD="runcvm_ip"
    elif command -v ip >/dev/null 2>&1; then
      log INFO "Using system ip command"
      IP_CMD="ip"
    elif command -v ifconfig >/dev/null 2>&1; then
      log INFO "Using ifconfig (fallback)"
      IP_CMD=""
      USE_IFCONFIG=1
    else
      log ERROR "No network configuration tools available!"
      log DEBUG "Checking PATH: $PATH"
      if is_debug; then
        log DEBUG "RUNCVM_GUEST dir contents:"
        ls -la "$RUNCVM_GUEST" 2>/dev/null || echo "    not found"
        log DEBUG "RUNCVM_GUEST/bin dir contents:"
        ls -la "$RUNCVM_GUEST/bin" 2>/dev/null || echo "    not found"
      fi
      IP_CMD=""
    fi
    
    if [ -n "$IP_CMD" ]; then
      # Bring interface up first
      log INFO "Bringing eth0 up..."
      $IP_CMD link set eth0 up
      RET=$?
      log DEBUG "ip link set eth0 up returned: $RET"
      sleep 0.5
      
      # Set MTU if specified
      if [ -n "$FC_MTU" ]; then
        $IP_CMD link set eth0 mtu "$FC_MTU" 2>/dev/null || true
      fi
      
      # Add IP address
      log INFO "Adding IP $FC_IP/$FC_PREFIX to eth0..."
      $IP_CMD addr add "$FC_IP/$FC_PREFIX" dev eth0
      RET=$?
      log DEBUG "ip addr add returned: $RET"
      
      if [ -n "$FC_GW" ] && [ "$FC_GW" != "-" ]; then
        log INFO "Setting default gateway to $FC_GW..."
        $IP_CMD route add default via "$FC_GW" dev eth0
        RET=$?
        log DEBUG "ip route add returned: $RET"
        
        # Add route to container bridge IP (169.254.1.1) for 9P diod server
        # The bridge IP is directly reachable via same network segment
        log INFO "Adding route to container bridge 169.254.1.1..."
        $IP_CMD route add 169.254.1.1/32 dev eth0 2>/dev/null || true
      fi
      
      # Show network config for debugging
      if is_debug; then
        log INFO "Final eth0 configuration:"
        $IP_CMD addr show eth0
        log INFO "Final routing table:"
        $IP_CMD route show
        log INFO "Link state:"
        $IP_CMD link show eth0
      fi
      
    elif [ "$USE_IFCONFIG" = "1" ]; then
      log INFO "Using ifconfig"
      # Convert prefix to netmask (simplified for common cases)
      case "$FC_PREFIX" in
        8)  FC_NETMASK="255.0.0.0" ;;
        16) FC_NETMASK="255.255.0.0" ;;
        24) FC_NETMASK="255.255.255.0" ;;
        *)  FC_NETMASK="255.255.255.0" ;;
      esac
      
      ifconfig eth0 "$FC_IP" netmask "$FC_NETMASK" up
      
      if [ -n "$FC_GW" ] && [ "$FC_GW" != "-" ]; then
        route add default gw "$FC_GW" 2>/dev/null || true
      fi
      
      if is_debug; then
        ifconfig eth0
        route -n
      fi
    fi
    
    # Test connectivity (optional, non-blocking)
    if [ -n "$FC_GW" ] && [ "$FC_GW" != "-" ]; then
      log INFO "Testing connectivity to gateway $FC_GW..."
      if is_debug; then
        if [ "$HAVE_RUNCVM_TOOLS" = "1" ]; then
          runcvm_busybox ping -c 1 -W 1 "$FC_GW" 2>&1 && echo "  Gateway reachable!" || echo "  Gateway not reachable (this may be normal)"
        elif command -v ping >/dev/null 2>&1; then
          ping -c 1 -W 1 "$FC_GW" 2>&1 && echo "  Gateway reachable!" || echo "  Gateway not reachable (this may be normal)"
        fi
      else
        # Silent ping test - just for connectivity check
        if [ "$HAVE_RUNCVM_TOOLS" = "1" ]; then
          runcvm_busybox ping -c 1 -W 1 "$FC_GW" >/dev/null 2>&1 && log DEBUG "Gateway reachable" || log DEBUG "Gateway not reachable"
        elif command -v ping >/dev/null 2>&1; then
          ping -c 1 -W 1 "$FC_GW" >/dev/null 2>&1 && log DEBUG "Gateway reachable" || log DEBUG "Gateway not reachable"
        fi
      fi
    fi
  elif [ ! -d /sys/class/net/eth0 ]; then
    log INFO "SKIPPING network config - eth0 not found"
  fi
elif [ -d /sys/class/net/eth0 ]; then
  # Fallback: Try DHCP
  log INFO "No network config file, trying DHCP..."
  ip link set eth0 up 2>/dev/null || ifconfig eth0 up 2>/dev/null || true
  if command -v udhcpc >/dev/null 2>&1; then
    udhcpc -i eth0 -n -q 2>/dev/null || true
  fi
else
  log INFO "No network config and no eth0 interface!"
fi

log INFO "========== NETWORK SETUP END =========="

# Setup DNS
if [ -f /.runcvm-resolv.conf ]; then
  cp /.runcvm-resolv.conf /etc/resolv.conf 2>/dev/null || true
fi

# ==========================================================================
# FUSE VOLUME MOUNTS - Pure FUSE over vsock using runcvm-fuse-client
# ==========================================================================
mount_fuse_volumes() {
  local fuse_config="/.runcvm/fuse-volumes"
  local fuse_client="/.runcvm/guest/bin/runcvm-fuse-client"
  
  log INFO "Checking for FUSE volumes..."
  
  if [ ! -f "$fuse_config" ]; then
    log INFO "No fuse-volumes config found - volumes are static copies"
    return 0
  fi
  
  # Check if fuse client binary exists
  if [ ! -x "$fuse_client" ]; then
    log ERROR "FUSE client not found at $fuse_client"
    log INFO "Falling back to static copy mode"
    return 1
  fi
  
  # Load vsock kernel modules (required for guest-to-host communication)
  log INFO "Loading vsock kernel modules..."
  modprobe vsock 2>/dev/null || true
  modprobe vmw_vsock_virtio_transport 2>/dev/null || true
  modprobe virtio_vsock 2>/dev/null || true
  
  # Detailed vsock diagnostics
  log INFO "=== VSOCK DIAGNOSTICS ==="
  
  # Check vsock device
  if [ -e /dev/vsock ]; then
    log INFO "  /dev/vsock: exists"
    ls -la /dev/vsock 2>&1 | busybox head -1 | busybox sed 's/^/    /'
  else
    log WARN "  /dev/vsock: MISSING"
  fi
  
  # Check virtio devices
  log INFO "  Virtio devices:"
  ls -la /sys/bus/virtio/devices/ 2>/dev/null | busybox sed 's/^/    /' || log INFO "    No virtio devices found"
  
  # Check for vsock-related drivers
  log INFO "  Loaded vsock modules:"
  lsmod 2>/dev/null | grep -i vsock | busybox sed 's/^/    /' || log INFO "    (none or built-in)"
  
  # Check vsock transport registration
  if [ -d /sys/class/vsock ]; then
    log INFO "  /sys/class/vsock: exists"
    ls -la /sys/class/vsock/ 2>/dev/null | busybox sed 's/^/    /'
  else
    log WARN "  /sys/class/vsock: MISSING (no transport registered)"
  fi
  
  # Check if virtio_vsock driver is bound
  for dev in /sys/bus/virtio/devices/*; do
    if [ -d "$dev" ]; then
      local dev_name=$(basename "$dev")
      local driver=$(cat "$dev/modalias" 2>/dev/null || echo "unknown")
      log INFO "    $dev_name: $driver"
      if [ -e "$dev/driver" ]; then
        local bound_driver=$(basename "$(readlink "$dev/driver")")
        log INFO "      Bound driver: $bound_driver"
      else
        log WARN "      No driver bound!"
      fi
    fi
  done
  
  log INFO "=== END VSOCK DIAGNOSTICS ==="
  
  # Check if vsock is usable by verifying:
  # 1. /dev/vsock exists
  # 2. A vsock virtio device is bound to the driver
  local vsock_device_found=0
  for dev in /sys/bus/virtio/devices/*; do
    if [ -d "$dev" ] && [ -e "$dev/driver" ]; then
      local modalias=$(cat "$dev/modalias" 2>/dev/null || echo "")
      if echo "$modalias" | grep -q "d00000013"; then
        vsock_device_found=1
        log INFO "vsock device found and driver bound"
        break
      fi
    fi
  done
  
  if [ "$vsock_device_found" -ne 1 ] || [ ! -e /dev/vsock ]; then
    log WARN "vsock not available"
    log INFO "  /dev/vsock exists: $([ -e /dev/vsock ] && echo 'yes' || echo 'no')"
    log INFO "  vsock device found: $([ $vsock_device_found -eq 1 ] && echo 'yes' || echo 'no')"
    log INFO "Falling back to static copy mode"
    return 1
  fi
  log INFO "FUSE Transport: vsock (Guest -> Host CID 2, port 5742)"
  log INFO "Mount type: FUSE (live, bidirectional)"
  log INFO "Binary: $fuse_client"
  
  # Config format: src:dst:opts
  # Mount each volume via runcvm-fuse-client
  while IFS=: read -r src_path dst opts; do
    [ -z "$src_path" ] && continue
    [ -z "$dst" ] && continue
    
    log INFO "  Mounting $src_path -> $dst..."
    mkdir -p "$dst"
    
    # Launch runcvm-fuse-client for this mount
    # It connects to the host daemon via vsock and mounts at $dst
    "$fuse_client" \
      --host-cid 2 \
      --port 5742 \
      --mount "$dst" \
      --source "$src_path" \
      2>&1 | sed 's/^/    /' &
    
    # Give it a moment to sync
    sleep 1
    
    # Check if sync succeeded by verifying files exist in destination
    # Our simple client syncs files rather than mounting a full FUSE filesystem
    local file_count=$(ls -1 "$dst" 2>/dev/null | wc -l)
    if [ "$file_count" -gt 0 ]; then
      log INFO "  ✓ Successfully synced $file_count files to $dst (vsock)"
    else
      log INFO "  ✗ Failed to sync $dst"
      log INFO "    Falling back to static copy mode"
    fi
  done < "$fuse_config"
  
  log INFO "  FUSE mounts complete"
}

log INFO "========== FUSE VOLUME MOUNTS =========="
mount_fuse_volumes
log INFO "========== FUSE VOLUME MOUNTS END =========="

# ========== DROPBEAR SSH SERVER FOR DOCKER EXEC ==========
# docker exec uses SSH to connect to the VM, so we need dropbear running
log INFO "========== DROPBEAR SSH SETUP =========="

SSHD_PORT=22222
DROPBEAR_DIR="/.runcvm/dropbear"

if [ "$HAVE_RUNCVM_TOOLS" = "1" ]; then
  mkdir -p "$DROPBEAR_DIR"
  
  # Check if we need to generate keys
  if [ ! -f "$DROPBEAR_DIR/key" ]; then
    log INFO "Generating dropbear SSH keys..."
    # Generate ed25519 key
    "$RUNCVM_LD" "$RUNCVM_GUEST/usr/bin/dropbearkey" -t ed25519 -f "$DROPBEAR_DIR/key" >/dev/null 2>&1
    
    # Extract public key for EPKA
    KEY_PUBLIC=$("$RUNCVM_LD" "$RUNCVM_GUEST/usr/bin/dropbearkey" -y -f "$DROPBEAR_DIR/key" 2>/dev/null | grep ^ssh | cut -d' ' -f2)
    
    # Create EPKA config
    cat > "$DROPBEAR_DIR/epka.json" << EPKAEOF
[{"user":"root","keytype":"ssh-ed25519","key":"$KEY_PUBLIC","options":"no-X11-forwarding","comments":""}]
EPKAEOF
    chmod 400 "$DROPBEAR_DIR/epka.json" "$DROPBEAR_DIR/key"
    log INFO "SSH keys generated"
  else
    log INFO "Using pre-generated SSH keys"
  fi
  
  # Start dropbear SSH server
  log INFO "Starting dropbear on port $SSHD_PORT..."
  EPKA_LIB="$RUNCVM_GUEST/tmp/dropbear/libepka_file.so"
  
  if [ -f "$EPKA_LIB" ]; then
    "$RUNCVM_LD" "$RUNCVM_GUEST/usr/sbin/dropbear" -REF -p "$SSHD_PORT" \
      -A "$EPKA_LIB,$DROPBEAR_DIR/epka.json" \
      -P "$DROPBEAR_DIR/dropbear.pid" 2>/dev/null &
    sleep 0.5
    if [ -f "$DROPBEAR_DIR/dropbear.pid" ]; then
      log INFO "Dropbear started (PID: $(cat $DROPBEAR_DIR/dropbear.pid))"
    else
      log INFO "Warning - Dropbear may not have started correctly"
    fi
  else
    log INFO "Warning - EPKA library not found at $EPKA_LIB"
    log INFO "docker exec may not work"
  fi
else
  log INFO "RunCVM tools not available, skipping dropbear"
  log INFO "docker exec will not work"
fi

log INFO "========== DROPBEAR SETUP END =========="

# Determine what to run
# Priority:
# 1. /.runcvm-entrypoint (saved by RunCVM)
# 2. /docker-entrypoint.sh (nginx and many others)
# 3. Direct nginx execution
# 4. /bin/sh fallback

if [ -f /.runcvm-entrypoint ] && [ -s /.runcvm-entrypoint ]; then
  # Read entrypoint line by line into an array-like structure
  set --
  while IFS= read -r line || [ -n "$line" ]; do
    set -- "$@" "$line"
  done < /.runcvm-entrypoint
  
  log INFO "Running saved entrypoint: $@"
  exec "$@"
  
elif [ -x /docker-entrypoint.sh ]; then
  log INFO "Running /docker-entrypoint.sh"
  # For nginx, docker-entrypoint.sh expects "nginx" "-g" "daemon off;" as args
  if [ -f /etc/nginx/nginx.conf ]; then
    exec /docker-entrypoint.sh nginx -g "daemon off;"
  else
    exec /docker-entrypoint.sh
  fi
  
elif [ -f /etc/nginx/nginx.conf ] && command -v nginx >/dev/null 2>&1; then
  log INFO "Running nginx directly"
  exec nginx -g "daemon off;"
  
else
  log INFO "No entrypoint found, starting shell"
  exec /bin/sh
fi
INITEOF
  busybox chmod +x "$init_script"
  
  # Save the original entrypoint if we have it
  if [ -f "$entrypoint_file" ]; then
    busybox cp "$entrypoint_file" "${staging_dir}/.runcvm-entrypoint"
    log "  Saved entrypoint: $(busybox head -1 ${staging_dir}/.runcvm-entrypoint)"
  fi
  
  # Copy essential networking tools from RunCVM guest
  # These are needed because minimal images (like nginx) don't have ip/ifconfig
  # IMPORTANT: We must copy to the SAME path (/.runcvm/guest) because the binaries
  # use relative RPATH that depends on the directory structure
  log "  Copying network tools to rootfs..."
  
  if [ -d "$RUNCVM_GUEST" ]; then
    # Create the same directory structure
    busybox mkdir -p "${staging_dir}/.runcvm/guest"
    
    # Copy the dynamic linker and libraries
    if [ -d "$RUNCVM_GUEST/lib" ]; then
      busybox cp -a "$RUNCVM_GUEST/lib" "${staging_dir}/.runcvm/guest/"
      log "    Copied lib/ (dynamic linker)"
    fi
    
    # Copy usr/lib for additional libraries
    if [ -d "$RUNCVM_GUEST/usr/lib" ]; then
      busybox mkdir -p "${staging_dir}/.runcvm/guest/usr"
      busybox cp -a "$RUNCVM_GUEST/usr/lib" "${staging_dir}/.runcvm/guest/usr/"
      log "    Copied usr/lib/"
    fi
    
    # Copy bin directory with busybox and symlinks
    if [ -d "$RUNCVM_GUEST/bin" ]; then
      busybox cp -a "$RUNCVM_GUEST/bin" "${staging_dir}/.runcvm/guest/"
      log "    Copied bin/ (busybox, ip, etc.)"
    fi
    
    # Copy sbin if exists
    if [ -d "$RUNCVM_GUEST/sbin" ]; then
      busybox cp -a "$RUNCVM_GUEST/sbin" "${staging_dir}/.runcvm/guest/"
      log "    Copied sbin/"
    fi
    
    # Copy usr/bin and usr/sbin
    if [ -d "$RUNCVM_GUEST/usr/bin" ]; then
      busybox mkdir -p "${staging_dir}/.runcvm/guest/usr"
      busybox cp -a "$RUNCVM_GUEST/usr/bin" "${staging_dir}/.runcvm/guest/usr/"
      log "    Copied usr/bin/"
    fi
    if [ -d "$RUNCVM_GUEST/usr/sbin" ]; then
      busybox mkdir -p "${staging_dir}/.runcvm/guest/usr"
      busybox cp -a "$RUNCVM_GUEST/usr/sbin" "${staging_dir}/.runcvm/guest/usr/"
      log "    Copied usr/sbin/"
    fi
    
    # Copy tmp/dropbear (contains EPKA library for SSH authentication)
    if [ -d "$RUNCVM_GUEST/tmp/dropbear" ]; then
      busybox mkdir -p "${staging_dir}/.runcvm/guest/tmp"
      busybox cp -a "$RUNCVM_GUEST/tmp/dropbear" "${staging_dir}/.runcvm/guest/tmp/"
      log "    Copied tmp/dropbear/ (EPKA library)"
    fi
    
    # Copy scripts directory (needed for runcvm-vm-exec)
    if [ -d "$RUNCVM_GUEST/scripts" ]; then
      busybox cp -a "$RUNCVM_GUEST/scripts" "${staging_dir}/.runcvm/guest/"
      log "    Copied scripts/"
    fi
  else
    log "  WARNING: RUNCVM_GUEST not found, network tools may not work"
  fi
  
  # Copy pre-generated dropbear keys from container (generated by runcvm-ctr-entrypoint)
  if [ -d "/.runcvm/dropbear" ] && [ -f "/.runcvm/dropbear/key" ]; then
    busybox mkdir -p "${staging_dir}/.runcvm/dropbear"
    busybox cp -a "/.runcvm/dropbear/"* "${staging_dir}/.runcvm/dropbear/"
    log "    Copied pre-generated dropbear keys"
  fi
  
  # Copy the config file (needed by some scripts)
  if [ -f "/.runcvm/config" ]; then
    busybox cp "/.runcvm/config" "${staging_dir}/.runcvm/config"
    log "    Copied /.runcvm/config"
  fi
  # Copy fuse-volumes file - CRITICAL for volume mounting in VM
  log_debug "Checking FUSE_CONFIG at $FUSE_CONFIG"
  if [ -f "$FUSE_CONFIG" ]; then
    log_debug "FUSE_CONFIG exists, copying to staging..."
    if [ -s "$FUSE_CONFIG" ]; then
      busybox cp "$FUSE_CONFIG" "${staging_dir}/.runcvm/fuse-volumes"
      log_debug "Copied to ${staging_dir}/.runcvm/fuse-volumes"
      log_debug "Contents:"
      busybox cat "${staging_dir}/.runcvm/fuse-volumes" 2>&1 | while read line; do log_debug "  $line"; done
    else
      log "WARNING: FUSE_CONFIG exists but is empty"
    fi
  else
    log "WARNING: FUSE_CONFIG does not exist at $FUSE_CONFIG"
  fi

  # Copy kernel modules for 9P support from Alpine kernel
  log "  Copying 9P kernel modules..."
  local fc_modules_dir="$RUNCVM_GUEST/kernels/firecracker/latest/modules"
  if [ -d "$fc_modules_dir" ]; then
    # Find the kernel version directory
    local kernel_ver=$(busybox ls "$fc_modules_dir" 2>/dev/null | busybox head -1)
    if [ -n "$kernel_ver" ] && [ -d "$fc_modules_dir/$kernel_ver" ]; then
      log "    Found kernel modules for version: $kernel_ver"
      
      # Create modules directory in staging
      busybox mkdir -p "${staging_dir}/lib/modules/$kernel_ver"
      
      # Copy 9P modules specifically
      if [ -d "$fc_modules_dir/$kernel_ver/kernel/net/9p" ]; then
        busybox mkdir -p "${staging_dir}/lib/modules/$kernel_ver/kernel/net"
        busybox cp -a "$fc_modules_dir/$kernel_ver/kernel/net/9p" \
          "${staging_dir}/lib/modules/$kernel_ver/kernel/net/"
        log "      Copied 9P modules"
      fi
      
      # Copy vsock modules if they exist
      if [ -d "$fc_modules_dir/$kernel_ver/kernel/net/vmw_vsock" ]; then
        busybox mkdir -p "${staging_dir}/lib/modules/$kernel_ver/kernel/net"
        busybox cp -a "$fc_modules_dir/$kernel_ver/kernel/net/vmw_vsock" \
          "${staging_dir}/lib/modules/$kernel_ver/kernel/net/"
        log "      Copied vsock modules"
      fi
      
      # Copy modules.* files (needed for modprobe)
      busybox cp "$fc_modules_dir/$kernel_ver"/modules.* \
        "${staging_dir}/lib/modules/$kernel_ver/" 2>/dev/null || true
      log "      Copied module metadata files"
    else
      log "    WARNING: No kernel modules found in $fc_modules_dir"
    fi
  else
    log "    WARNING: Firecracker modules directory not found: $fc_modules_dir"
  fi

  
  # Create a simpler runcvm-vm-exec for Firecracker that doesn't depend on complex paths
  # This is called by dropbear when docker exec connects via SSH
  busybox cat > "${staging_dir}/.runcvm/guest/scripts/runcvm-vm-exec" << 'VMEXECEOF'
#!/bin/sh
# Simplified runcvm-vm-exec for Firecracker
# Called by dropbear SSH when docker exec connects
# Arguments: <uid:gid:groups> <cwd_encoded> <args_encoded> <env_encoded>

from_bin() {
  tr '\200\201\202\203\204\205' "\011\012\040\047\042\134"
}

uidgid="$1"
cwd_bin="$2"
args_bin="$3"
env_bin="$4"

# Decode working directory
cwd=$(printf '%s' "$cwd_bin" | from_bin)

# Change to working directory
cd "$cwd" 2>/dev/null || cd /

# Decode and execute the command
# The args are newline-separated after decoding
if [ -n "$args_bin" ]; then
  # Create a temporary script to handle the decoded args properly
  tmpscript="/tmp/exec-$$"
  printf '%s' "$args_bin" | from_bin > "$tmpscript.args"
  
  # Read first line as command, rest as args
  cmd=""
  args=""
  first=1
  while IFS= read -r line || [ -n "$line" ]; do
    if [ "$first" = "1" ]; then
      cmd="$line"
      first=0
    else
      if [ -z "$args" ]; then
        args="$line"
      else
        args="$args
$line"
      fi
    fi
  done < "$tmpscript.args"
  rm -f "$tmpscript.args"
  
  # Execute the command
  if [ -n "$args" ]; then
    # Multiple arguments - use eval to handle them
    printf '%s\n' "$args" | {
      set -- "$cmd"
      while IFS= read -r arg || [ -n "$arg" ]; do
        set -- "$@" "$arg"
      done
      exec "$@"
    }
  else
    # Single command
    exec "$cmd"
  fi
else
  exec /bin/sh
fi
VMEXECEOF
  busybox chmod +x "${staging_dir}/.runcvm/guest/scripts/runcvm-vm-exec"
  log "    Created simplified runcvm-vm-exec"
  
  # Save network configuration for the VM
  if [ -f "/.runcvm/network/devices/eth0" ]; then
    read DOCKER_IF DOCKER_IF_MAC DOCKER_IF_MTU DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_IP_GW < /.runcvm/network/devices/eth0
    # Firecracker uses a different MAC (AA:FC:00:xx:xx:xx)
    local fc_mac=$(echo "$DOCKER_IF_MAC" | busybox sed 's/^..:..:../AA:FC:00/')
    log "  Saving network config: IP=$DOCKER_IF_IP/$DOCKER_IF_IP_NETPREFIX GW=$DOCKER_IF_IP_GW MAC=$fc_mac"
    cat > "${staging_dir}/.runcvm-network" << NETEOF
FC_IP="$DOCKER_IF_IP"
FC_PREFIX="$DOCKER_IF_IP_NETPREFIX"
FC_GW="$DOCKER_IF_IP_GW"
FC_MTU="$DOCKER_IF_MTU"
FC_MAC="$fc_mac"
NETEOF
  fi
  
  # Save resolv.conf
  if [ -f "/etc/resolv.conf" ]; then
    busybox cp /etc/resolv.conf "${staging_dir}/.runcvm-resolv.conf"
  fi
  
  # Step 2: Calculate rootfs size
  # Add 50% overhead + 256MB for ext4 metadata
  local rootfs_size=$(( (staged_size * 3 / 2) + 256 ))
  [ "$rootfs_size" -lt 512 ] && rootfs_size=512
  
  log "Step 2/3: Creating rootfs image..."
  log "  Rootfs size: ${rootfs_size}MB (${staged_size}MB content + overhead)"
  
  # Check overlay disk space
  local overlay_avail=$(busybox df -m / 2>/dev/null | busybox awk 'NR==2 {print $4}')
  log "  Overlay (/) available: ${overlay_avail}MB"
  
  if [ "$overlay_avail" -lt "$rootfs_size" ]; then
    busybox rm -rf "$staging_dir"
    error "Insufficient disk space on overlay (need ${rootfs_size}MB, have ${overlay_avail}MB)"
  fi
  
  # Create rootfs from staging directory
  log "  Source: $staging_dir"  
  log "  Destination: $rootfs_path"
  
  local mke2fs_start=$(busybox date +%s)
  
  if ! create_rootfs_from_dir "$staging_dir" "$rootfs_path" "$rootfs_size"; then
    log "mke2fs debug info:"
    log "  Staged content size: $(busybox du -sm "$staging_dir" | busybox cut -f1)MB"
    log "  Image size: ${rootfs_size}MB"
    busybox rm -rf "$staging_dir"
    error "Failed to create rootfs"
  fi
  
  local mke2fs_end=$(busybox date +%s)
  local mke2fs_time=$(( mke2fs_end - mke2fs_start ))
  
  # Cleanup staging
  log "  Cleaning up staging area..."
  busybox rm -rf "$staging_dir"
  
  local final_size=$(busybox du -sm "$rootfs_path" 2>/dev/null | busybox cut -f1)
  log "  Rootfs ready: ${final_size}MB (created in ${mke2fs_time}s)"
  
  # Determine kernel path - using Firecracker kernel Image (uncompressed)
  # The kernel is copied to /opt/runcvm/kernels/firecracker/vmlinux in Dockerfile
  # which becomes /.runcvm/guest/kernels/firecracker/vmlinux at runtime
  local fc_default_kernel="$RUNCVM_GUEST/kernels/firecracker/vmlinux"
  local kernel_path="${RUNCVM_FC_KERNEL_PATH:-$fc_default_kernel}"
  
  if [ ! -f "$kernel_path" ]; then
    error "Firecracker kernel not found: $kernel_path"
  fi
  
  # DEBUG: Show kernel file details
  log "DEBUG: Kernel file information:"
  log "  Path: $kernel_path"
  log "  Size: $(busybox ls -lh "$kernel_path" 2>/dev/null | busybox awk '{print $5}')"
  log "  Modified: $(busybox ls -l "$kernel_path" 2>/dev/null | busybox awk '{print $6, $7, $8}')"
  if command -v sha256sum >/dev/null 2>&1; then
    log "  SHA256: $(sha256sum "$kernel_path" 2>/dev/null | busybox cut -d' ' -f1)"
  fi
  
  # Build boot arguments - use /init which we created in the rootfs
  # Note: 9p.debug=0xff enables verbose 9P logging to debug transport issues
  local boot_args="init=/init console=ttyS0 reboot=k panic=1 pci=off root=/dev/vda rw 9p.debug=0xff"
  
  # Parse memory size (remove 'M' suffix if present)
  local mem_mb="${RUNCVM_MEM_SIZE%M}"
  [ -z "$mem_mb" ] && mem_mb=768
  
  # Parse CPU count
  local vcpu_count="${RUNCVM_CPUS:-1}"
  [ "$vcpu_count" -le 0 ] && vcpu_count=$(busybox nproc)
  
  log "Step 3/3: Starting Firecracker VM..."
  log "  Kernel: $kernel_path"
  log "  Config: $vcpu_count vCPUs, ${mem_mb}MB RAM"
  
  # Build network config if available
  local network_config=""
  if [ -f "/.runcvm/network/devices/eth0" ]; then
    read DOCKER_IF DOCKER_IF_MAC DOCKER_IF_MTU DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_IP_GW < /.runcvm/network/devices/eth0
    local fc_mac=$(echo "$DOCKER_IF_MAC" | busybox sed 's/^..:..:../AA:FC:00/')
    local tap_name="tap-$DOCKER_IF"
    local bridge_name="br-$DOCKER_IF"
    
    log "  Network: $tap_name ($fc_mac)"
    
    # Create TAP device for Firecracker
    # Unlike QEMU which uses scripts (qemu-ifup), Firecracker expects the TAP to exist
    log "  Creating TAP device $tap_name..."
    ip tuntap add dev "$tap_name" mode tap
    
    # Add TAP to the bridge (which was created by runcvm-ctr-entrypoint)
    log "  Adding $tap_name to bridge $bridge_name..."
    ip link set dev "$tap_name" master "$bridge_name"
    
    # Set MTU and bring up
    ip link set dev "$tap_name" up mtu "${DOCKER_IF_MTU:-1500}"
    
    # Debug: show bridge and tap status
    if [ "$RUNCVM_LOG_LEVEL" = "DEBUG" ]; then
      log "  Bridge status:"
      ip link show "$bridge_name" 2>&1 | busybox sed 's/^/    /'
      log "  TAP status:"
      ip link show "$tap_name" 2>&1 | busybox sed 's/^/    /'
    fi
    

    # Add MASQUERADE rule for outbound traffic from the VM
    # This allows the VM to reach external networks (internet)
    log "  Adding NAT MASQUERADE rule for VM outbound traffic..."
    if [ -n "$RUNCVM_GUEST" ] && [ -d "$RUNCVM_GUEST/usr/lib/xtables" ]; then
      XTABLES_LIBDIR=$RUNCVM_GUEST/usr/lib/xtables xtables-nft-multi iptables         -t nat -A POSTROUTING -s "$DOCKER_IF_IP" -o eth0 -j MASQUERADE 2>/dev/null &&         log "    Added MASQUERADE via xtables-nft-multi" || true
    elif command -v iptables >/dev/null 2>&1; then
      iptables -t nat -A POSTROUTING -s "$DOCKER_IF_IP" -o eth0 -j MASQUERADE 2>/dev/null &&         log "    Added MASQUERADE via iptables" || true
    fi

    network_config=",\"network-interfaces\":[{\"iface_id\":\"eth0\",\"guest_mac\":\"$fc_mac\",\"host_dev_name\":\"$tap_name\"}]"
  fi

  # Build vsock config for FUSE volumes
  # FORCE ENABLE vsock for debugging - always add the vsock device
  local vsock_config=',"vsock":{"guest_cid":3,"uds_path":"/run/firecracker.vsock"}'
  log "  vsock: FORCE ENABLED (debugging)"
  log "    guest_cid: 3"
  log "    uds_path: /run/firecracker.vsock"
  
  # Create Firecracker config file
  cat > "$FIRECRACKER_CONFIG" << CFGEOF
{
  "boot-source": {
    "kernel_image_path": "$kernel_path",
    "boot_args": "$boot_args"
  },
  "drives": [
    {
      "drive_id": "rootfs",
      "path_on_host": "$rootfs_path",
      "is_root_device": true,
      "is_read_only": false
    }
  ],
  "machine-config": {
    "vcpu_count": $vcpu_count,
    "mem_size_mib": $mem_mb
  }${network_config}${vsock_config}
}
CFGEOF

  # ALWAYS show Firecracker config for debugging vsock issue
  log "=== FIRECRACKER CONFIG (checking vsock) ==="
  busybox cat "$FIRECRACKER_CONFIG" | while read line; do log "  $line"; done
  log "=== END FIRECRACKER CONFIG ==="
  
  # Verify vsock is in config
  if busybox grep -q "vsock-device" "$FIRECRACKER_CONFIG"; then
    log "✓ vsock-device is PRESENT in Firecracker config"
  else
    log "✗ vsock-device is MISSING from Firecracker config!"
  fi

  # Run Firecracker
  "$FIRECRACKER_BIN" --no-api --config-file "$FIRECRACKER_CONFIG"
  
  local exit_code=$?
  log "Firecracker exited with code $exit_code"
  
  # Cleanup
  busybox rm -f "$rootfs_path" "$FIRECRACKER_CONFIG"
  
  return $exit_code
}

main "$@"
