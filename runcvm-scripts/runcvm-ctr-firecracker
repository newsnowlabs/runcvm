#!/.runcvm/guest/bin/bash

# RunCVM Firecracker Launcher
# Launches a Firecracker microVM using config file mode (for console output)
#
# STRATEGY: Copy container files to /dev/shm, then create rootfs on overlay
# This avoids the self-copy problem where mke2fs would copy the rootfs into itself

set -o errexit -o pipefail

# Load original environment
. /.runcvm/config

# Load defaults
. $RUNCVM_GUEST/scripts/runcvm-ctr-defaults && unset PATH

FIRECRACKER_BIN="$RUNCVM_GUEST/sbin/firecracker"
FIRECRACKER_CONFIG="/run/.firecracker-config.json"

log() {
  echo "RunCVM-FC: $1" >&2
}

error() {
  echo "RunCVM-FC ERROR: $1" >&2
  exit 1
}

# Create rootfs image from a source directory
create_rootfs_from_dir() {
  local source_dir="$1"
  local image_path="$2"
  local size_mb="$3"
  
  log "Creating ext4 rootfs: $image_path (${size_mb}MB) from $source_dir"
  
  # Create sparse file
  if ! busybox truncate -s "${size_mb}M" "$image_path"; then
    error "Failed to create sparse file"
  fi
  
  # Create ext4 filesystem populated with source directory contents
  if ! mke2fs -F -t ext4 -E root_owner=0:0 -d "$source_dir" "$image_path" 2>&1; then
    log "mke2fs failed"
    busybox rm -f "$image_path"
    return 1
  fi
  
  log "Rootfs created successfully"
  return 0
}

# Main function
main() {
  log "Starting Firecracker microVM launcher..."
  
  # Check for Firecracker binary
  if [ ! -x "$FIRECRACKER_BIN" ]; then
    error "Firecracker binary not found: $FIRECRACKER_BIN"
  fi
  
  # ==========================================================================
  # STRATEGY: Copy container files to /dev/shm, then create rootfs on overlay
  # ==========================================================================
  # Problem: /vm is a bind mount of /, so any file at /x is also at /vm/x
  #          This causes mke2fs -d /vm to copy the rootfs into itself
  #
  # Solution: 
  #   1. Copy /vm contents to /dev/shm/rootfs-staging (separate tmpfs)
  #   2. Create rootfs at /rootfs.ext4 (on overlay, has disk space)
  #   3. mke2fs reads from /dev/shm, writes to /rootfs.ext4
  #   4. No self-copy because source (/dev/shm) != destination parent (/)
  # ==========================================================================
  
  local staging_dir="/dev/shm/rootfs-staging"
  local rootfs_path="/rootfs.ext4"
  
  # Calculate source size (excluding .runcvm which has RunCVM binaries)
  log "Calculating container size (excluding .runcvm)..."
  
  local source_size=$(busybox du -sm --exclude='.runcvm' "$RUNCVM_VM_MOUNTPOINT" 2>/dev/null | busybox cut -f1)
  [ -z "$source_size" ] && source_size=100
  
  log "Container filesystem size: ${source_size}MB"
  
  # Check if /dev/shm has enough space for staging
  local shm_avail=$(busybox df -m /dev/shm 2>/dev/null | busybox awk 'NR==2 {print $4}')
  local shm_needed=$(( source_size + 50 ))  # Add 50MB buffer
  
  log "/dev/shm available: ${shm_avail}MB, need for staging: ${shm_needed}MB"
  
  if [ "$shm_avail" -lt "$shm_needed" ]; then
    log ""
    log "============================================================"
    log "ERROR: /dev/shm too small for staging"
    log "============================================================"
    log ""
    log "Container size: ${source_size}MB"
    log "/dev/shm available: ${shm_avail}MB"
    log "/dev/shm is sized by the -m (memory) flag"
    log ""
    log "SOLUTION: Increase VM memory to at least ${shm_needed}m"
    log ""
    log "  docker run --runtime=runcvm -m ${shm_needed}m \\"
    log "    -e RUNCVM_HYPERVISOR=firecracker nginx"
    log ""
    log "============================================================"
    error "Insufficient /dev/shm for staging (need ${shm_needed}MB, have ${shm_avail}MB)"
  fi
  
  # Step 1: Copy container files to staging area
  log "Step 1/3: Copying container files to staging area..."
  log "  Source: $RUNCVM_VM_MOUNTPOINT (excluding .runcvm)"
  log "  Destination: $staging_dir"
  log "  This may take 30-60 seconds for large images..."
  
  busybox rm -rf "$staging_dir"
  busybox mkdir -p "$staging_dir"
  
  # Use tar to copy, excluding .runcvm directory
  local copy_start=$(busybox date +%s)
  
  if ! (cd "$RUNCVM_VM_MOUNTPOINT" && busybox tar -cf - --exclude='.runcvm' . 2>/dev/null | busybox tar -xf - -C "$staging_dir" 2>/dev/null); then
    error "Failed to copy container files to staging"
  fi
  
  local copy_end=$(busybox date +%s)
  local copy_time=$(( copy_end - copy_start ))
  
  local staged_size=$(busybox du -sm "$staging_dir" 2>/dev/null | busybox cut -f1)
  log "  Staging complete: ${staged_size}MB copied in ${copy_time}s"
  
  # Step 1b: Create init script in staging area
  # This init script will be /init in the rootfs and runs the container's entrypoint
  log "  Creating init script..."
  
  # Read the original entrypoint from runcvm config
  local entrypoint_file="/.runcvm/entrypoint"
  local init_script="${staging_dir}/init"
  
  # Create a minimal init script
  cat > "$init_script" << 'INITEOF'
#!/bin/sh
# Firecracker minimal init for RunCVM
# This runs as PID 1 inside the Firecracker VM

# Mount essential filesystems
mount -t proc proc /proc 2>/dev/null || true
mount -t sysfs sys /sys 2>/dev/null || true
mount -t devtmpfs dev /dev 2>/dev/null || true

# Create essential device nodes if devtmpfs failed
if [ ! -c /dev/null ]; then
  mknod -m 666 /dev/null c 1 3
  mknod -m 666 /dev/zero c 1 5
  mknod -m 666 /dev/random c 1 8
  mknod -m 666 /dev/urandom c 1 9
  mknod -m 666 /dev/tty c 5 0
  mknod -m 620 /dev/console c 5 1
  mknod -m 666 /dev/ptmx c 5 2
fi

# Mount pts for proper terminal support
mkdir -p /dev/pts /dev/shm
mount -t devpts devpts /dev/pts 2>/dev/null || true
mount -t tmpfs tmpfs /dev/shm 2>/dev/null || true

# Create tmpfs for /run and /tmp
mkdir -p /run /tmp
mount -t tmpfs tmpfs /run 2>/dev/null || true
mount -t tmpfs tmpfs /tmp 2>/dev/null || true

# Create symlinks
ln -sf /proc/self/fd /dev/fd 2>/dev/null || true
ln -sf /proc/self/fd/0 /dev/stdin 2>/dev/null || true
ln -sf /proc/self/fd/1 /dev/stdout 2>/dev/null || true
ln -sf /proc/self/fd/2 /dev/stderr 2>/dev/null || true

# Setup hostname
[ -f /etc/hostname ] && hostname -F /etc/hostname 2>/dev/null || true

# Setup networking if eth0 exists
if [ -d /sys/class/net/eth0 ]; then
  ip link set lo up 2>/dev/null || true
  ip link set eth0 up 2>/dev/null || true
  # Try DHCP or use static IP from kernel cmdline
  if command -v udhcpc >/dev/null 2>&1; then
    udhcpc -i eth0 -n -q 2>/dev/null || true
  fi
fi

# Determine what to run
# Priority:
# 1. /.runcvm-entrypoint (saved by RunCVM)
# 2. /docker-entrypoint.sh (nginx and many others)
# 3. Direct nginx execution
# 4. /bin/sh fallback

if [ -f /.runcvm-entrypoint ] && [ -s /.runcvm-entrypoint ]; then
  # Read entrypoint line by line into an array-like structure
  set --
  while IFS= read -r line || [ -n "$line" ]; do
    set -- "$@" "$line"
  done < /.runcvm-entrypoint
  
  echo "RunCVM-FC init: Running saved entrypoint: $@"
  exec "$@"
  
elif [ -x /docker-entrypoint.sh ]; then
  echo "RunCVM-FC init: Running /docker-entrypoint.sh"
  # For nginx, docker-entrypoint.sh expects "nginx" "-g" "daemon off;" as args
  if [ -f /etc/nginx/nginx.conf ]; then
    exec /docker-entrypoint.sh nginx -g "daemon off;"
  else
    exec /docker-entrypoint.sh
  fi
  
elif [ -f /etc/nginx/nginx.conf ] && command -v nginx >/dev/null 2>&1; then
  echo "RunCVM-FC init: Running nginx directly"
  exec nginx -g "daemon off;"
  
else
  echo "RunCVM-FC init: No entrypoint found, starting shell"
  exec /bin/sh
fi
INITEOF
  busybox chmod +x "$init_script"
  
  # Save the original entrypoint if we have it
  if [ -f "$entrypoint_file" ]; then
    busybox cp "$entrypoint_file" "${staging_dir}/.runcvm-entrypoint"
    log "  Saved entrypoint: $(busybox head -1 ${staging_dir}/.runcvm-entrypoint)"
  fi
  
  # Step 2: Calculate rootfs size
  # Add 50% overhead + 256MB for ext4 metadata
  local rootfs_size=$(( (staged_size * 3 / 2) + 256 ))
  [ "$rootfs_size" -lt 512 ] && rootfs_size=512
  
  log "Step 2/3: Creating rootfs image..."
  log "  Rootfs size: ${rootfs_size}MB (${staged_size}MB content + overhead)"
  
  # Check overlay disk space
  local overlay_avail=$(busybox df -m / 2>/dev/null | busybox awk 'NR==2 {print $4}')
  log "  Overlay (/) available: ${overlay_avail}MB"
  
  if [ "$overlay_avail" -lt "$rootfs_size" ]; then
    busybox rm -rf "$staging_dir"
    error "Insufficient disk space on overlay (need ${rootfs_size}MB, have ${overlay_avail}MB)"
  fi
  
  # Create rootfs from staging directory
  log "  Source: $staging_dir"  
  log "  Destination: $rootfs_path"
  
  local mke2fs_start=$(busybox date +%s)
  
  if ! create_rootfs_from_dir "$staging_dir" "$rootfs_path" "$rootfs_size"; then
    log "mke2fs debug info:"
    log "  Staged content size: $(busybox du -sm "$staging_dir" | busybox cut -f1)MB"
    log "  Image size: ${rootfs_size}MB"
    busybox rm -rf "$staging_dir"
    error "Failed to create rootfs"
  fi
  
  local mke2fs_end=$(busybox date +%s)
  local mke2fs_time=$(( mke2fs_end - mke2fs_start ))
  
  # Cleanup staging
  log "  Cleaning up staging area..."
  busybox rm -rf "$staging_dir"
  
  local final_size=$(busybox du -sm "$rootfs_path" 2>/dev/null | busybox cut -f1)
  log "  Rootfs ready: ${final_size}MB (created in ${mke2fs_time}s)"
  
  # Determine kernel path
  local fc_default_kernel="$RUNCVM_GUEST/firecracker-kernel"
  local kernel_path="${RUNCVM_FC_KERNEL_PATH:-$fc_default_kernel}"
  
  if [ ! -f "$kernel_path" ]; then
    error "Firecracker kernel not found: $kernel_path"
  fi
  
  # Build boot arguments - use /init which we created in the rootfs
  local boot_args="init=/init console=ttyS0 reboot=k panic=1 pci=off root=/dev/vda rw"
  
  # Parse memory size (remove 'M' suffix if present)
  local mem_mb="${RUNCVM_MEM_SIZE%M}"
  [ -z "$mem_mb" ] && mem_mb=768
  
  # Parse CPU count
  local vcpu_count="${RUNCVM_CPUS:-1}"
  [ "$vcpu_count" -le 0 ] && vcpu_count=$(busybox nproc)
  
  log "Step 3/3: Starting Firecracker VM..."
  log "  Kernel: $kernel_path"
  log "  Config: $vcpu_count vCPUs, ${mem_mb}MB RAM"
  
  # Build network config if available
  local network_config=""
  if [ -f "/.runcvm/network/devices/eth0" ]; then
    read DOCKER_IF DOCKER_IF_MAC DOCKER_IF_MTU DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_IP_GW < /.runcvm/network/devices/eth0
    local fc_mac=$(echo "$DOCKER_IF_MAC" | busybox sed 's/^..:..:../AA:FC:00/')
    log "  Network: tap-$DOCKER_IF ($fc_mac)"
    network_config=",\"network-interfaces\":[{\"iface_id\":\"eth0\",\"guest_mac\":\"$fc_mac\",\"host_dev_name\":\"tap-$DOCKER_IF\"}]"
  fi
  
  # Create Firecracker config file
  cat > "$FIRECRACKER_CONFIG" << CFGEOF
{
  "boot-source": {
    "kernel_image_path": "$kernel_path",
    "boot_args": "$boot_args"
  },
  "drives": [
    {
      "drive_id": "rootfs",
      "path_on_host": "$rootfs_path",
      "is_root_device": true,
      "is_read_only": false
    }
  ],
  "machine-config": {
    "vcpu_count": $vcpu_count,
    "mem_size_mib": $mem_mb
  }${network_config}
}
CFGEOF

  # Run Firecracker
  "$FIRECRACKER_BIN" --no-api --config-file "$FIRECRACKER_CONFIG"
  
  local exit_code=$?
  log "Firecracker exited with code $exit_code"
  
  # Cleanup
  busybox rm -f "$rootfs_path" "$FIRECRACKER_CONFIG"
  
  return $exit_code
}

main "$@"
