#!/.runcvm/guest/bin/bash

# DEBUG
if [[ "$RUNCVM_BREAK" =~ (prenet|postnet) ]]; then set -x; fi

# SAVE ENTRYPOINT
args=("$@")
printf "%s\n" "${args[@]}" >/.runcvm/entrypoint

# SET HOME ENV VAR IF NEEDED

# - See https://github.com/moby/moby/issues/2968#issuecomment-35822318
#   for details of how Docker sets HOME.
#
# - What this means is that:
#   1. if HOME is defined in the image and
#      docker run:
#      a. does not define HOME
#         - config.json process.env[] will show the image-defined value and this value will be used
#         - docker exec
#           - does not define HOME, then process.json env[] will show the image-defined value and this value will be used
#           - does define HOME, then process.json env[] will show the exec-defined value and this value will be used
#      b. does define HOME, config.json process.env[] will show the docker run-defined value and this value will be used
#         - docker exec
#           - does not define HOME, then process.json env[] will show the docker run-defined value and this value will be used
#           - does define HOME, then process.json env[] will show the exec-defined value and this value will be used
#   (the above is irrespective of -u setting)
#
#   2. if HOME is not defined in the image and
#      docker run:
#      a. does not define HOME
#         - config.json process.env[] will show no HOME value and the user's default homedir will be used
#         - docker exec
#           - does not define HOME, then process.json env[] will show no HOME value and the user's default homedir will be used
#           - does define HOME, then process.json env[] will show the exec-defined value and this value will be used
#      b. does define HOME, config.json process.env[] will show the docker run-defined value and this value will be used
#         - docker exec
#           - does not define HOME, then process.json env[] will show the docker run-defined value and this value will be used
#           - does define HOME, then process.json env[] will show the exec-defined value and this value will be used

# Problem in 2a for us with docker run and docker exec is that while we save the requested uid:gid, we set the actual uid:gid to 0:0
# to allow us to run virtiofsd (and, today, qemu) (in the docker run case) and access the qemu guest agent socket (in the docker exec case - though use of the agent is deprecated in favour of ssh).
#
# Where HOME is not explicitly defined, this leads to docker setting HOME to root's default homedir (typically /root),
# for the calls to runcvm-ctr-entrypoint and runcvm-ctr-exec (respectively).
#
# How then do we distinguish this case from the case where HOME is explicitly set to /root?
# The answer is that runcvm-runtime must check for HOME in env[] and indicate its presence in the calls to runcvm-ctr-entrypoint and runcvm-ctr-exec.
#
# runcvm-runtime does this:
# - in the docker run case, via the RUNCVM_HAS_HOME env var
# - in the docker exec case, via an argument to runcvm-ctr-exec

# Here we check RUNCVM_HAS_HOME to determine whether the HOME env var was set either in the image, or via docker run.
# If not, then we set HOME to the requested user's default homedir in accordance with https://github.com/moby/moby/issues/2968.

if [ "$RUNCVM_HAS_HOME" == "0" ]; then
  HOME=$($RUNCVM_GUEST/usr/bin/getent passwd "${RUNCVM_UIDGID%%:*}" | $RUNCVM_GUEST/bin/cut -d':' -f6)
fi

if [ -z "$RUNCVM_CPUS" ] || [ "$RUNCVM_CPUS" -le 0 ]; then
  RUNCVM_CPUS=$($RUNCVM_GUEST/bin/busybox nproc)
fi

# SAVE ENVIRONMENT
export -n SHLVL OLDPWD

export >/.runcvm/config

# NOW LOAD DEFAULT ENV AND PATH
. $RUNCVM_GUEST/scripts/runcvm-ctr-defaults

# LOAD IP MANIPULATION FUNCTIONS
. $RUNCVM_GUEST/scripts/runcvm-ip-functions

# SAVE PWD
busybox pwd >/.runcvm/pwd

# DEBUG
if [[ "$RUNCVM_BREAK" =~ prenet ]]; then bash; fi

setup_bridge_networking() {
  IFS=$'\n' read -d '' -r DOCKER_GW_IF DOCKER_GW_IF_IP <<< \
    $(ip -json route show | jq -r '.[] | (select(.dst == "default") | .dev, .gateway)')

  QEMU_BRIDGE_IP=169.254.1.1
  RUNCVM_DNS_IP=169.254.169.254

  mkdir -p /.runcvm/network
  rm -rf /.runcvm/network/devices
  mkdir -p /.runcvm/network/devices

  ip -json route show | jq -r '.[] | select(.scope != "link" and .dst != "default") | "\(.dst) \(.gateway) \(.dev) \(.prefsrc)"' >/.runcvm/network/routes

  for if in $(ip -json link show | jq -r '.[] | .ifname')
  do
    [ "$if" = "lo" ] && continue

    local DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_MAC DOCKER_IF_MTU
    IFS=$'\n' read -d '' -r DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_MAC DOCKER_IF_MTU <<< \
      $(ip -json addr show "$if" | jq -r '.[0] | .addr_info[0].local, .addr_info[0].prefixlen, .address, .mtu')

    if [ "$if" = "$DOCKER_GW_IF" ]; then
      printf "%s %s %s %s %s %s %s\n" \
        "$if" "$DOCKER_IF_MAC" "${DOCKER_IF_MTU:-1500}" "$DOCKER_IF_IP" "$DOCKER_IF_IP_NETPREFIX" "$DOCKER_GW_IF_IP" "-" \
        >/.runcvm/network/devices/$if
      ln -sf "$if" /.runcvm/network/devices/default
    else
      printf "%s %s %s %s %s %s %s\n" \
        "$if" "$DOCKER_IF_MAC" "${DOCKER_IF_MTU:-1500}" "$DOCKER_IF_IP" "$DOCKER_IF_IP_NETPREFIX" "-" "-" \
        >/.runcvm/network/devices/$if
    fi

    ip addr flush dev "$if"

    local QEMU_BRIDGE="br-$if"
    ip link add "$QEMU_BRIDGE" type bridge forward_delay 0 ageing 0
    ip link set dev "$if" master "$QEMU_BRIDGE"
    ip link set dev "$if" up
    ip link set dev "$QEMU_BRIDGE" up

    local DOCKER_NET
    DOCKER_NET=$(ip_prefix_to_network "$DOCKER_IF_IP" "$DOCKER_IF_IP_NETPREFIX")/"$DOCKER_IF_IP_NETPREFIX"
    ip route add "$DOCKER_NET" dev "$QEMU_BRIDGE"

    if [ "$if" = "$DOCKER_GW_IF" ]; then
      ip addr add "$QEMU_BRIDGE_IP" dev "$QEMU_BRIDGE"
      ip route add default via "$DOCKER_GW_IF_IP" dev "$QEMU_BRIDGE"

      XTABLES_LIBDIR=$RUNCVM_GUEST/usr/lib/xtables xtables-nft-multi iptables -t nat -A PREROUTING -d $RUNCVM_DNS_IP/32 -p udp -m udp --dport 53 -j REDIRECT

      if [[ "$RUNCVM_DISPLAY_MODE" = "vnc" ]] || is_natural_int "$RUNCVM_QEMU_VNC_DISPLAY"; then
        XTABLES_LIBDIR=$RUNCVM_GUEST/usr/lib/xtables xtables-nft-multi iptables -t nat -A PREROUTING -p tcp -m tcp --dport $((RUNCVM_QEMU_VNC_DISPLAY+5900)) -j REDIRECT
      fi

      XTABLES_LIBDIR=$RUNCVM_GUEST/usr/lib/xtables xtables-nft-multi iptables -t nat -A POSTROUTING -o "$QEMU_BRIDGE" -s $QEMU_BRIDGE_IP/32 -p udp -m udp --sport 53 -j SNAT --to-source "$DOCKER_IF_IP"
      XTABLES_LIBDIR=$RUNCVM_GUEST/usr/lib/xtables xtables-nft-multi iptables -t nat -A POSTROUTING -o "$QEMU_BRIDGE" -s $QEMU_BRIDGE_IP/32 -p udp -m udp --dport 53 -j SNAT --to-source "$DOCKER_IF_IP"
      XTABLES_LIBDIR=$RUNCVM_GUEST/usr/lib/xtables xtables-nft-multi iptables -t nat -A POSTROUTING -o "$QEMU_BRIDGE" -s $QEMU_BRIDGE_IP/32 -p tcp -m tcp --dport $SSHD_PORT -j SNAT --to-source $RUNCVM_DNS_IP
    fi
  done

  cat /vm/etc/resolv.conf >/etc/resolv.conf
  RESOLV_CONF_NEW=$(busybox sed -r "s/127.0.0.11/$RUNCVM_DNS_IP/" /vm/etc/resolv.conf)
  echo "$RESOLV_CONF_NEW" >/vm/etc/resolv.conf

  dnsmasq -u root --no-hosts
}

setup_macvtap_networking() {
  IFS=$'\n' read -d '' -r DOCKER_GW_IF DOCKER_GW_IF_IP <<< \
    $(ip -json route show | jq -r '.[] | (select(.dst == "default") | .dev, .gateway)')

  mkdir -p /.runcvm/network
  rm -rf /.runcvm/network/devices
  mkdir -p /.runcvm/network/devices

  ip -json route show | jq -r '.[] | select(.scope != "link" and .dst != "default") | "\(.dst) \(.gateway) \(.dev) \(.prefsrc)"' >/.runcvm/network/routes

  for if in $(ip -json link show | jq -r '.[] | .ifname')
  do
    [ "$if" = "lo" ] && continue

    local DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_MAC DOCKER_IF_MTU
    IFS=$'\n' read -d '' -r DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_MAC DOCKER_IF_MTU <<< \
      $(ip -json addr show "$if" | jq -r '.[0] | .addr_info[0].local, .addr_info[0].prefixlen, .address, .mtu')

    local vm_mac macvtap_if macvtap_index macvtap_dev macvtap_minor gateway
    vm_mac=$(busybox sed -r 's/^..:..:../52:54:00/' <<<$DOCKER_IF_MAC)
    macvtap_if="macvtap-$if"

    if ! ip link show "$macvtap_if" >/dev/null 2>&1; then
      ip link add link "$if" name "$macvtap_if" type macvtap mode bridge
    fi

    ip link set dev "$if" up || true
    ip link set dev "$macvtap_if" address "$vm_mac" 2>/dev/null || true
    ip link set dev "$macvtap_if" up
    ip link set dev "$macvtap_if" mtu "${DOCKER_IF_MTU:-1500}"

    macvtap_index=$(cat /sys/class/net/$macvtap_if/ifindex)
    macvtap_dev=/dev/tap$macvtap_index

    if ! [ -c "$macvtap_dev" ]; then
      macvtap_minor=$((200 + macvtap_index))
      busybox mknod "$macvtap_dev" c 10 "$macvtap_minor"
    fi

    chmod 600 "$macvtap_dev"

    gateway="-"
    if [ "$if" = "$DOCKER_GW_IF" ] && [ -n "$DOCKER_GW_IF_IP" ]; then
      gateway="$DOCKER_GW_IF_IP"
      ln -sf "$if" /.runcvm/network/devices/default
    fi

    printf "%s %s %s %s %s %s %s\n" \
      "$if" "$DOCKER_IF_MAC" "${DOCKER_IF_MTU:-1500}" "$DOCKER_IF_IP" "$DOCKER_IF_IP_NETPREFIX" "$gateway" "$macvtap_dev" \
      >/.runcvm/network/devices/$if
  done
}

if [ "$RUNCVM_NETWORK" = "macvtap" ]; then
  setup_macvtap_networking
else
  setup_bridge_networking
fi

# LAUNCH VIRTIOFSD
$RUNCVM_GUEST/scripts/runcvm-ctr-virtiofsd &

# DEBUG
if [[ "$RUNCVM_BREAK" =~ postnet ]]; then bash; fi

# LAUNCH INIT SUPERVISING QEMU
# FIXME: Add -v to debug
exec $RUNCVM_GUEST/sbin/runcvm-init -c $RUNCVM_GUEST/scripts/runcvm-ctr-qemu
